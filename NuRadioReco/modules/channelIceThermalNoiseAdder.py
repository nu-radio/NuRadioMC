import astropy.coordinates
import functools
import json
import numpy as np
import os
import scipy.constants
import scipy.interpolate
from scipy.interpolate import interp1d
from urllib.request import urlretrieve
import warnings

import NuRadioReco.detector.antennapattern
import NuRadioReco.framework.channel
import NuRadioReco.framework.sim_station
from NuRadioReco.modules.base.module import register_run
from NuRadioReco.utilities import units, ice, geometryUtilities, signal_processing

import logging
logger = logging.getLogger('NuRadioReco.channelThermalNoiseAdder')


class channelThermalNoiseAdder:
    """
    Module to generate thermal noise from ice
    This class is a stripped version of channelGalacticNoiseAdder
    Intead of using a skymap, the module uses pre generated effective antenna temperatures,
    generated by Steffen's effective temperature code which was modified by Felix
    (see NuRadioMC/examples/simulate_effective_ice_temperature )
    """

    def __init__(self):
        self.__antenna_pattern_provider = NuRadioReco.detector.antennapattern.AntennaPatternProvider()


    @functools.lru_cache(maxsize=1024 * 32)
    def get_cached_antenna_response(self, antenna_pattern, zen, azi, *ant_orient):
        return antenna_pattern.get_antenna_response_vectorized(self.freqs, zen, azi, *ant_orient)

    def solid_angle(self, theta, d_theta, d_phi):
        return np.abs(np.sin(theta) * np.sin(d_theta / 2) * 2 * d_phi)

    def get_temperature_from_json(self, temperature_file):
        """
        Function to open the effective temperature files created by
        NuRadioMC/examples/simulate_effective_ice_temperature
        The effective temperatures are generated at an antenna depth in function of incident angle
        by integrating ice temperature (weighted by attenuation effects) along a ray path starting from an incident angle.
        For more info see the example.
        This module was made for RNO-G but given you have an ice temperature / attenuation profile one can re-generate these files
        for arbitrary experiments
        """
        with open(temperature_file, "r") as file_open:
            temperature_file_dict = json.load(file_open)
        z_antenna = temperature_file_dict["z_antenna"]
        theta = temperature_file_dict["theta"] * units.rad
        eff_temperature = temperature_file_dict["eff_temperature"]
        return z_antenna, theta, eff_temperature



    def begin(self, sim_library_dir, nr_phi_bins=64, channel_depth_profile=None, debug=False):
        """
        Set up important parameters for the module

        Parameters
        ----------
        sim_library_dir : str
            Directory where to look for the pre-generated effective temperature json files
        nr_phi_bins : int
            Binning of the azimuth, this can be reduced for azimuthally symmetric antennas,
            such as vertically polarized antennas
        channel_depth_profile : dict
            Depth of detector antennas formatted as {antenna_nr : depth}.
            If None, uses the antenna depths of RNO-G.
        debug : bool
            If True removes randomization of electric field phases and polarizations to speed up testing
        """
        self.temperature_files = [f"{sim_library_dir}/eff_temperature_-100m_ntheta100_GL3.json",
                                  f"{sim_library_dir}/eff_temperature_-40m_ntheta100.json",
                                  f"{sim_library_dir}/eff_temperature_-1.0m_ntheta100_GL3.json",
                                  f"{sim_library_dir}/eff_temperature_-2.0m_ntheta100_GL3.json", 
                                  f"{sim_library_dir}/eff_temperature_-3.0m_ntheta100_GL3.json", 
                                  ]

        self.eff_temperature = {}
        for temperature_file in self.temperature_files:
            z_antenna, self.thetas, eff_temperature = self.get_temperature_from_json(temperature_file)
            self.eff_temperature[z_antenna] = eff_temperature

        self.nr_theta_bins = len(self.thetas)

        if channel_depth_profile is None:
            self.channel_depths = {i : -100 for i in [0, 1, 2, 3, 4, 8, 9, 10, 11, 21, 22, 23]}
            for i in [5, 6, 7]:
                self.channel_depths[i] = -40
            for i in [12, 13, 14, 15, 16, 17, 18, 19, 20]:
                self.channel_depths[i] = -1.0
        else:
            self.channel_depths = channel_depth_profile

        self.debug = debug
        if self.debug:
            nr_phi_bins = 32
        self.phis = np.linspace(0 * units.degree, 360 * units.degree, nr_phi_bins)
        return


    @register_run()
    def run(
            self,
            event,
            station,
            detector,
            passband=None
    ):

        """
        Adds noise resulting from thermal emission to the channel traces

        Parameters
        ----------
        event: Event object
            The event containing the station to whose channels noise shall be added
        station: Station object
            The station whose channels noise shall be added to
        detector: Detector object
            The detector description
        passband: list of float, optional
            Lower and upper bound of the frequency range in which noise shall be
            added. The default (no passband specified) is [10, 1600] MHz
        """

        # check that for all channels channel.get_frequencies() is identical
        last_freqs = None
        for channel in station.iter_channels():
            if last_freqs is not None and (
                    not np.allclose(last_freqs, channel.get_frequencies(), rtol=0, atol=0.1 * units.MHz)):
                logger.error("The frequencies of each channel must be the same, but they are not!")
                return

            last_freqs = channel.get_frequencies()

        freqs = last_freqs
        self.freqs = freqs
        d_f = freqs[2] - freqs[1]

        if passband is None:
            passband = [10 * units.MHz, 1600 * units.MHz]
        passband_filter = (freqs > passband[0]) & (freqs < passband[1])

        c_vac = scipy.constants.c * units.m / units.s

        channel_spectra = {}
        for channel in station.iter_channels():
            channel_spectra[channel.get_id()] = channel.get_frequency_spectrum()

        d_thetas = np.diff(self.thetas)
        d_phis = np.diff(self.phis)
        for phi, d_phi in zip(self.phis, d_phis):
            for theta_i, (theta, d_theta) in enumerate(zip(self.thetas, d_thetas)):
                solid_angle = self.solid_angle(theta, d_theta, d_phi)

                noise_spectrum = np.zeros((3, freqs.shape[0]), dtype=complex)
                channel_noise_spec = np.zeros_like(noise_spectrum)
                for channel in station.iter_channels():
                    channel_id = channel.get_id()
                    depth = self.channel_depths[channel_id]
                    eff_temperature = self.eff_temperature[depth]

                    # calculate spectral radiance of radio signal using rayleigh-jeans law
                    efield_amplitude = signal_processing.get_electric_field_from_temperature(freqs[passband_filter],
                                                                                             eff_temperature[theta_i],
                                                                                             solid_angle)

                    # assign random phases to electric field
                    if self.debug:
                        phases = 0 * np.ones(len(efield_amplitude))
                    else:
                        phases = np.random.uniform(0, 2. * np.pi, len(efield_amplitude))

                    noise_spectrum[1][passband_filter] = np.exp(1j * phases) * efield_amplitude
                    noise_spectrum[2][passband_filter] = np.exp(1j * phases) * efield_amplitude

                    antenna_pattern = self.__antenna_pattern_provider.load_antenna_pattern(
                        detector.get_antenna_model(station.get_id(), channel.get_id()),
                        )
                    antenna_orientation = detector.get_antenna_orientation(station.get_id(), channel.get_id())

                    # add random polarizations and phase to electric field
                    if self.debug:
                        polarizations = [0.] * len(efield_amplitude)
                    else:
                        polarizations = np.random.uniform(0, 2. * np.pi, len(efield_amplitude))

                    channel_noise_spec[1][passband_filter] = noise_spectrum[1][passband_filter] * np.cos(polarizations)
                    channel_noise_spec[2][passband_filter] = noise_spectrum[2][passband_filter] * np.sin(polarizations)

                    # fold electric field with antenna response
                    antenna_response = self.get_cached_antenna_response(antenna_pattern, theta, phi,
                                                                        *antenna_orientation)
                    channel_noise_spectrum = (
                        antenna_response['theta'] * channel_noise_spec[1]
                        + antenna_response['phi'] * channel_noise_spec[2]
                    )

                    # add noise spectrum from pixel in the sky to channel spectrum
                    channel_spectra[channel.get_id()] += channel_noise_spectrum

        # store the updated channel spectra
        for channel in station.iter_channels():
            channel.set_frequency_spectrum(channel_spectra[channel.get_id()], "same")


if __name__ == "__main__":
    import datetime
    import matplotlib.pyplot as plt
    from NuRadioReco.detector.RNO_G.rnog_detector import Detector
    from NuRadioReco.framework.event import Event
    from NuRadioReco.framework.station import Station
    from NuRadioReco.framework.channel import Channel

    station_id = 23
    nr_samples = 2048
    sampling_rate = 3.2 * units.GHz
    frequencies = np.fft.rfftfreq(nr_samples, d=1./sampling_rate)
    channel_ids = [0]

    detector = Detector(database_connection='RNOG_public', log_level=logging.NOTSET,
                        select_stations=station_id)
    detector_time = datetime.datetime(2023, 8, 1)
    detector.update(detector_time)

    event = Event(run_number=-1, event_id=-1)
    station = Station(station_id)
    station.set_station_time(detector.get_detector_time())
    for channel_id in channel_ids:
        channel = Channel(channel_id)
        channel.set_frequency_spectrum(np.zeros_like(frequencies, dtype=np.complex128), sampling_rate)
        station.add_channel(channel)
    event.set_station(station)

    sim_library_dir="/inser/path/to/eff_tmp/files/here"

    thermal_noise_adder = channelThermalNoiseAdder()
    thermal_noise_adder.begin(sim_library_dir=sim_library_dir)
    thermal_noise_adder.run(event, station, detector)

    station = event.get_station()
    channel = station.get_channel(0)
    plt.plot(channel.get_times(), channel.get_trace())
    plt.show()
    plt.clf()

    plt.plot(channel.get_frequencies(), np.abs(channel.get_frequency_spectrum()))
    plt.savefig("test_thermal_noise")
