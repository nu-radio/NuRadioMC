<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NuRadioMC.SignalProp.analyticraytracing &mdash; NuRadio 2.1.2-beta documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="/home/runner/work/NuRadioMC/NuRadioMC/documentation/source/custom_scripts/styling.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../main.html" class="icon icon-home"> NuRadio
            <img src="../../../_static/logo_small.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.1.2-beta
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Introduction/pages/welcome_page.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../Introduction/pages/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../Introduction/pages/installation.html">Installing NuRadioMC / NuRadioReco</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/installation.html#requirements">Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/installation.html#installation-using-pip">Installation using Pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/installation.html#development-version">Development version</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/installation.html#pythonpath">PYTHONPATH</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/installation.html#manual-installation">Manual installation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/installation.html#pip-installable-dependencies">Pip-installable dependencies</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/installation.html#core-dependencies">Core Dependencies</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/installation.html#optional-dependencies">Optional Dependencies</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/installation.html#not-pip-installable-packages">Not pip-installable packages</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../Introduction/pages/contributing.html">Contributing to NuRadioReco</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/contributing.html#workflow">Workflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/contributing.html#coding-conventions">Coding conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../Introduction/pages/contributing.html#how-to">How to</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/contributing.html#writing-docstrings">Writing docstrings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/contributing.html#update-the-version-number-dependencies">Update the version number / dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Introduction/pages/contributing.html#writing-additional-documentation">Writing additional documentation</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/contributing.html#headings-and-text">Headings and text</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/contributing.html#lists">Lists</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/contributing.html#links-and-cross-references">Links and cross-references</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../Introduction/pages/contributing.html#showing-code">Showing code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../NuRadioReco/pages/welcome_page.html">NuRadioReco Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html">Data Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#nur-files-and-how-to-use-them">.nur Files and How to Use Them</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#philosophy-and-basic-structure">Philosophy and Basic Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#reading-and-writing-nur-files">Reading and Writing .nur Files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#parameter-storage">Parameter Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#list-of-data-classes">List of Data Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#event">Event</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#radio-shower">Radio Shower</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#simshower">SimShower</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#station">Station</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#trigger">Trigger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#simstation">SimStation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#basetrace">BaseTrace</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#electric-field">Electric Field</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#channel">Channel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#hybrid-information">Hybrid Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#hybrid-shower">Hybrid Shower</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/event_structure.html#hybrid-detector">Hybrid Detector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/detector_tree.html">Detector Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html">Detector Description</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#the-detector-class">The Detector Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#detector-description-formats">Detector Description Formats</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#database">DataBase</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#json">JSON</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#dictionary">Dictionary</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#signal-chain-responses">Signal Chain Responses</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#genericdetector">GenericDetector</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#event-specific-changes">Event-Specific Changes</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#detector-description-in-event-files">Detector Description in Event Files</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#writing-the-detector">Writing the Detector</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#reading-the-detector">Reading the Detector</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector.html#detector-viewer">Detector Viewer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector_database_fields.html">Properties of Detector Description</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector_database_fields.html#antenna-table">Antenna Table</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector_database_fields.html#further-discussion-on-antenna-coordinates">Further Discussion on Antenna Coordinates</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/detector_database_fields.html#adc-table">ADC Table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html">Antenna Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#overview-of-available-antenna-models">Overview of available Antenna Models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#bicone-v8-infair">bicone_v8_infAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#bicone-v8-inf-n1-32">bicone_v8_inf_n1.32</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#bicone-v8-inf-n1-4">bicone_v8_inf_n1.4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#bicone-v8-inf-n1-78">bicone_v8_inf_n1.78</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-100mhz-inffirn">createLPDA_100MHz_InfFirn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-inffirn-n1-4">createLPDA_InfFirn_n1.4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-100mhz-z1cm-infirn-rg">createLPDA_100MHz_z1cm_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z1cm-infirn-boresighttoboundary">createLPDA_z1cm_InFirn_BoresightToBoundary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z10cm-infirn-rg">createLPDA_z10cm_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z1m-infirn-rg">createLPDA_z1m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z2m-infirn-rg">createLPDA_z2m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z2m-infirn-backlobe-norg">createLPDA_z2m_InFirn_Backlobe_NoRG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z3m-inair-rg">createLPDA_z3m_InAir_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z3m-infirn-boresighttoboundary">createLPDA_z3m_InFirn_BoresightToBoundary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z3mandlpdalen-infirn-boresighttoboundary">createLPDA_z3mAndLPDALen_InFirn_BoresightToBoundary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z5m-infirn-rg">createLPDA_z5m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z10m-infirn-rg">createLPDA_z10m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z100m-infirn-rg">createLPDA_z100m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-z200m-infirn-rg">createLPDA_z200m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-100mhz-infair">createLPDA_100MHz_InfAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#createlpda-100mhz-z1cm-inair-rg">createLPDA_100MHz_z1cm_InAir_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-hpol-inffirn">dip7cm_hpol_infFirn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-hpol-z2m-infirn-rg">dip7cm_hpol_z2m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-inffirn">dip7cm_InfFirn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z260mm-infirn-rg">dip7cm_z260mm_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z1m-infirn-rg">dip7cm_z1m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z2m-infirn-rg">dip7cm_z2m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z3m-infirn-rg-nearhorizontalhd">dip7cm_z3m_InFirn_RG_NearHorizontalHD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z5m-infirn-rg">dip7cm_z5m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z10m-infirn-rg">dip7cm_z10m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z20m-infirn-rg">dip7cm_z20m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z100m-infirn-rg">dip7cm_z100m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z200m-infirn-rg">dip7cm_z200m_InFirn_RG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-infair">dip7cm_InfAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z270mm-inair">dip7cm_z270mm_InAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z1m-inair">dip7cm_z1m_InAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z1m-inair-rg-nearhorizontalhd">dip7cm_z1m_InAir_RG_NearHorizontalHD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z1m-inair-rg-nearhorizontalhd2">dip7cm_z1m_InAir_RG_NearHorizontalHD2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z2m-inair">dip7cm_z2m_InAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#dip7cm-z5m-inair">dip7cm_z5m_InAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#ara-quadslot-data-measurement-fit">ARA_quadslot_data+measurement_fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#ara-bicone-data-measurement-fit">ARA_bicone_data+measurement_fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-vpol-4inch-center-1-73">RNOG_vpol_4inch_center_1.73</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-vpol-4inch-half-1-73">RNOG_vpol_4inch_half_1.73</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-vpol-4inch-wall-1-73">RNOG_vpol_4inch_wall_1.73</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-quadslot-v1-1-74">RNOG_quadslot_v1_1.74</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-quadslot-v2-1-74">RNOG_quadslot_v2_1.74</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#skala-inair">SKALA_InAir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/detector/antennamodels.html#rnog-quadslot-v3-air-rescaled-to-n1-74">RNOG_quadslot_v3_air_rescaled_to_n1.74</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/nur_modules.html">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/nur_modules.html#basic-module-structure">Basic Module Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/nur_modules.html#logging">Logging</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/event_display.html">Event Display</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/utilities.html#unit-system">Unit System</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/utilities.html#fourier-transformation">Fourier Transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/utilities.html#metaclasses">Metaclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/utilities.html#singleton">Singleton</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/code_documentation.html">Code Documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.html">NuRadioReco.framework package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.base_shower.html">NuRadioReco.framework.base_shower module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.base_station.html">NuRadioReco.framework.base_station module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.base_trace.html">NuRadioReco.framework.base_trace module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.channel.html">NuRadioReco.framework.channel module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.electric_field.html">NuRadioReco.framework.electric_field module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.event.html">NuRadioReco.framework.event module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.hybrid_information.html">NuRadioReco.framework.hybrid_information module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.hybrid_shower.html">NuRadioReco.framework.hybrid_shower module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.parameter_serialization.html">NuRadioReco.framework.parameter_serialization module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.parameters.html">NuRadioReco.framework.parameters module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.particle.html">NuRadioReco.framework.particle module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.radio_shower.html">NuRadioReco.framework.radio_shower module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.sim_channel.html">NuRadioReco.framework.sim_channel module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.sim_station.html">NuRadioReco.framework.sim_station module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.station.html">NuRadioReco.framework.station module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.framework.trigger.html">NuRadioReco.framework.trigger module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.html">NuRadioReco.modules package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.ARA.html">NuRadioReco.modules.ARA package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.ARIANNA.html">NuRadioReco.modules.ARIANNA package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.RNO_G.html">NuRadioReco.modules.RNO_G package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.base.html">NuRadioReco.modules.base package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.custom.html">NuRadioReco.modules.custom package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.io.html">NuRadioReco.modules.io package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.neutrinoVertexReconstructor.html">NuRadioReco.modules.neutrinoVertexReconstructor package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.phasedarray.html">NuRadioReco.modules.phasedarray package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.trigger.html">NuRadioReco.modules.trigger package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.analogToDigitalConverter.html">NuRadioReco.modules.analogToDigitalConverter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.beamFormingDirectionFitter.html">NuRadioReco.modules.beamFormingDirectionFitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelAddCableDelay.html">NuRadioReco.modules.channelAddCableDelay module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelAntennaDedispersion.html">NuRadioReco.modules.channelAntennaDedispersion module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelBandPassFilter.html">NuRadioReco.modules.channelBandPassFilter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelGalacticNoiseAdder.html">NuRadioReco.modules.channelGalacticNoiseAdder module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelGenericNoiseAdder.html">NuRadioReco.modules.channelGenericNoiseAdder module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelLengthAdjuster.html">NuRadioReco.modules.channelLengthAdjuster module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelMeasuredNoiseAdder.html">NuRadioReco.modules.channelMeasuredNoiseAdder module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelResampler.html">NuRadioReco.modules.channelResampler module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelSignalReconstructor.html">NuRadioReco.modules.channelSignalReconstructor module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelStopFilter.html">NuRadioReco.modules.channelStopFilter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelTemplateCorrelation.html">NuRadioReco.modules.channelTemplateCorrelation module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelTimeOffsetCalculator.html">NuRadioReco.modules.channelTimeOffsetCalculator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.channelTimeWindow.html">NuRadioReco.modules.channelTimeWindow module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.correlationDirectionFitter.html">NuRadioReco.modules.correlationDirectionFitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.cosmicRayEnergyReconstructor.html">NuRadioReco.modules.cosmicRayEnergyReconstructor module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.efieldAirToIcePropagator.html">NuRadioReco.modules.efieldAirToIcePropagator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.efieldTimeDirectionFitter.html">NuRadioReco.modules.efieldTimeDirectionFitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.efieldToVoltageConverter.html">NuRadioReco.modules.efieldToVoltageConverter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.efieldToVoltageConverterPerEfield.html">NuRadioReco.modules.efieldToVoltageConverterPerEfield module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.electricFieldBandPassFilter.html">NuRadioReco.modules.electricFieldBandPassFilter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.electricFieldResampler.html">NuRadioReco.modules.electricFieldResampler module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.electricFieldSignalReconstructor.html">NuRadioReco.modules.electricFieldSignalReconstructor module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.eventTypeIdentifier.html">NuRadioReco.modules.eventTypeIdentifier module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.sphericalWaveFitter.html">NuRadioReco.modules.sphericalWaveFitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.templateDirectionFitter.html">NuRadioReco.modules.templateDirectionFitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.triggerTimeAdjuster.html">NuRadioReco.modules.triggerTimeAdjuster module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.voltageToAnalyticEfieldConverter.html">NuRadioReco.modules.voltageToAnalyticEfieldConverter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.voltageToEfieldConverter.html">NuRadioReco.modules.voltageToEfieldConverter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.modules.voltageToEfieldConverterPerChannel.html">NuRadioReco.modules.voltageToEfieldConverterPerChannel module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.html">NuRadioReco.detector package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.ARA.html">NuRadioReco.detector.ARA package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.ARIANNA.html">NuRadioReco.detector.ARIANNA package</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.RNO_G.html">NuRadioReco.detector.RNO_G package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.amp.html">NuRadioReco.detector.amp module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.antennapattern.html">NuRadioReco.detector.antennapattern module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.detector.html">NuRadioReco.detector.detector module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.detector_sql.html">NuRadioReco.detector.detector_sql module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.detector_sys_uncertainties.html">NuRadioReco.detector.detector_sys_uncertainties module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.filterresponse.html">NuRadioReco.detector.filterresponse module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.generic_detector.html">NuRadioReco.detector.generic_detector module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.sql_to_json.html">NuRadioReco.detector.sql_to_json module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.test_detector_db.html">NuRadioReco.detector.test_detector_db module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.detector.visualize_detector.html">NuRadioReco.detector.visualize_detector module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.html">NuRadioReco.utilities package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.analytic_pulse.html">NuRadioReco.utilities.analytic_pulse module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.bandpass_filter.html">NuRadioReco.utilities.bandpass_filter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.cr_flux.html">NuRadioReco.utilities.cr_flux module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.diodeSimulator.html">NuRadioReco.utilities.diodeSimulator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.fft.html">NuRadioReco.utilities.fft module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.geometryUtilities.html">NuRadioReco.utilities.geometryUtilities module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.ice.html">NuRadioReco.utilities.ice module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.io_utilities.html">NuRadioReco.utilities.io_utilities module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.metaclasses.html">NuRadioReco.utilities.metaclasses module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.noise.html">NuRadioReco.utilities.noise module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.templates.html">NuRadioReco.utilities.templates module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.timing.html">NuRadioReco.utilities.timing module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.traceWindows.html">NuRadioReco.utilities.traceWindows module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.trace_utilities.html">NuRadioReco.utilities.trace_utilities module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.units.html">NuRadioReco.utilities.units module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioReco/apidoc/NuRadioReco.utilities.version.html">NuRadioReco.utilities.version module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioReco/pages/howto_documentation.html">Manuals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioReco/pages/how_to/vertex_reconstruction.html">Use the Vertex Reconstruction Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/how_to/vertex_reconstruction.html#creating-lookup-tables">Creating Lookup Tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/how_to/vertex_reconstruction.html#creating-electric-field-templates">Creating Electric Field Templates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioReco/pages/how_to/vertex_reconstruction.html#d-vs-3d-vertex-reconstructor">2D vs. 3D Vertex Reconstructor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../NuRadioMC/pages/welcome_page.html">NuRadioMC Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioMC/pages/code_documentation.html">Code Documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.html">NuRadioMC.EvtGen package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.NuRadioMCtoAraSim.html">NuRadioMC.EvtGen.NuRadioMCtoAraSim module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.NuRadioProposal.html">NuRadioMC.EvtGen.NuRadioProposal module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.create_tau_tab.html">NuRadioMC.EvtGen.create_tau_tab module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.generate_cylinder.html">NuRadioMC.EvtGen.generate_cylinder module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.generate_unforced.html">NuRadioMC.EvtGen.generate_unforced module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.generator.html">NuRadioMC.EvtGen.generator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.generator_ASCII.html">NuRadioMC.EvtGen.generator_ASCII module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.generator_skeleton.html">NuRadioMC.EvtGen.generator_skeleton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.hdf5_to_ASCII.html">NuRadioMC.EvtGen.hdf5_to_ASCII module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.readARAEventList.html">NuRadioMC.EvtGen.readARAEventList module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.EvtGen.readEventList_ASCII.html">NuRadioMC.EvtGen.readEventList_ASCII module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.html">NuRadioMC.SignalGen package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.ARZ.html">NuRadioMC.SignalGen.ARZ package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.HCRB2017.html">NuRadioMC.SignalGen.HCRB2017 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.askaryan.html">NuRadioMC.SignalGen.askaryan module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.emitter.html">NuRadioMC.SignalGen.emitter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalGen.parametrizations.html">NuRadioMC.SignalGen.parametrizations module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.html">NuRadioMC.SignalProp package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html">NuRadioMC.SignalProp.analyticraytracing module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.directRayTracing.html">NuRadioMC.SignalProp.directRayTracing module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.propagation.html">NuRadioMC.SignalProp.propagation module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.propagation_base_class.html">NuRadioMC.SignalProp.propagation_base_class module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.radioproparaytracing.html">NuRadioMC.SignalProp.radioproparaytracing module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.simulation.html">NuRadioMC.simulation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.simulation.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.simulation.simulation.html">NuRadioMC.simulation.simulation module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.html">NuRadioMC.utilities package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.Veff.html">NuRadioMC.utilities.Veff module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.attenuation.html">NuRadioMC.utilities.attenuation module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.cross_sections.html">NuRadioMC.utilities.cross_sections module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.dump_hdf5.html">NuRadioMC.utilities.dump_hdf5 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.earth_attenuation.html">NuRadioMC.utilities.earth_attenuation module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.fluxes.html">NuRadioMC.utilities.fluxes module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.inelasticities.html">NuRadioMC.utilities.inelasticities module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.medium.html">NuRadioMC.utilities.medium module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.medium_base.html">NuRadioMC.utilities.medium_base module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.merge_hdf5.html">NuRadioMC.utilities.merge_hdf5 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.plotting.html">NuRadioMC.utilities.plotting module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.runner.html">NuRadioMC.utilities.runner module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.runner_example.html">NuRadioMC.utilities.runner_example module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/apidoc/NuRadioMC.utilities.split_hdf5.html">NuRadioMC.utilities.split_hdf5 module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../NuRadioMC/pages/manuals.html">Manuals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html">Event Generation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html#events-in-a-cylindrical-volume">Events in a cylindrical volume</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html#input-parameters">Input parameters</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html#data-sets-and-attributes">Data sets and attributes</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html#atmospheric-muons-generated-on-a-flat-surface">Atmospheric muons generated on a flat surface</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/event_generation.html#nuradioproposal-as-a-standalone-module">NuRadioProposal as a standalone module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html">Signal Generation (electric field)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#frequency-domain-parameterisations">Frequency-domain parameterisations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#arz-semi-analytical-model">ARZ - semi-analytical model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#validity-of-the-parameterisations-and-the-arz-model">Validity of the parameterisations and the ARZ model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#timing">Timing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#using-the-same-shower-random-seed">Using the same shower. Random seed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_generation.html#fft-normalisation">FFT normalisation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html">Signal Propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#propagation-module">Propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#ray-tracing">Ray tracing</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#analytical-ray-tracer">Analytical ray tracer</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#radiopropa-numerical-ray-tracer-in-development">RadioPropa numerical ray tracer (in development)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#example-scripts">Example scripts</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#how-to-calculate-an-analytic-ray-path">How to calculate an analytic ray path</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/signal_propagation.html#how-to-calculate-an-radiopropa-ray-path">How to calculate an radiopropa ray path</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html">Ice and attenuation models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#ice-model-implementation">Ice model implementation</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#the-icemodel-and-icemodel-simple-class">The IceModel and IceModel_Simple class</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#radiopropaicewrapper">RadioPropaIceWrapper</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#available-models-in-nuradiomc">Available models in NuRadioMC</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#simple-ice-models">Simple ice models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#radiopropa-ice-models">RadioPropa ice models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#attenuation-model">Attenuation model</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#using-specific-models">Using specific models</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/icemodels.html#example-script">Example script</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/simulation_configuration.html">Simulation and configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/simulation_configuration.html#steering-files">Steering files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/simulation_configuration.html#config-files">Config files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/simulation_configuration.html#detector-description">Detector description</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/simulation_configuration.html#detector-simulation">Detector simulation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html">Calculating effective volume</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#installation">Installation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#run-an-effective-volume-simulation">Run an effective volume simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#generating-the-input-event-list">Generating the input event list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#running-the-simulation">Running the simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#more-details-the-detector-description">More details: the detector description</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#more-details-the-config-file">More details: the config file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../NuRadioMC/pages/Manuals/veff_tutorial.html#visualization-of-results">Visualization of results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../main.html">NuRadio</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../main.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>NuRadioMC.SignalProp.analyticraytracing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for NuRadioMC.SignalProp.analyticraytracing</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">NuRadioReco.utilities.geometryUtilities</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">backports.functools_lru_cache</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="kn">from</span> <span class="nn">NuRadioReco.utilities</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">NuRadioMC.utilities</span> <span class="kn">import</span> <span class="n">attenuation</span> <span class="k">as</span> <span class="n">attenuation_util</span>
<span class="kn">from</span> <span class="nn">NuRadioReco.framework.parameters</span> <span class="kn">import</span> <span class="n">electricFieldParameters</span> <span class="k">as</span> <span class="n">efp</span>
<span class="kn">from</span> <span class="nn">NuRadioMC.SignalProp.propagation_base_class</span> <span class="kn">import</span> <span class="n">ray_tracing_base</span>
<span class="kn">from</span> <span class="nn">NuRadioMC.SignalProp.propagation</span> <span class="kn">import</span> <span class="n">solution_types</span><span class="p">,</span> <span class="n">solution_types_revert</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>

<span class="c1"># check if CPP implementation is available</span>
<span class="n">cpp_available</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">NuRadioMC.SignalProp.CPPAnalyticRayTracing</span> <span class="kn">import</span> <span class="n">wrapper</span>
    <span class="n">cpp_available</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;using CPP version of ray tracer&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;trying to compile the CPP extension on-the-fly&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span>
                                 <span class="s2">&quot;install.sh&quot;</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">NuRadioMC.SignalProp.CPPAnalyticRayTracing</span> <span class="kn">import</span> <span class="n">wrapper</span>
        <span class="n">cpp_available</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compilation was sucessful, using CPP version of ray tracer&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compilation was not sucessful, using python version of ray tracer&quot;</span><span class="p">)</span>
        <span class="n">cpp_available</span> <span class="o">=</span> <span class="kc">False</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">analytic ray tracing solution</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">speed_of_light</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">m</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span>


<div class="viewcode-block" id="get_z_deep"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.get_z_deep">[docs]</a><span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_z_deep</span><span class="p">(</span><span class="n">ice_params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the z_deep needed for integral along the homogeneous ice</span>
<span class="sd">    to know the path length or the times. We obtain the depth for which</span>
<span class="sd">    the index of refraction is 0.035% away of that of deep ice. This</span>
<span class="sd">    calculation assumes a monotonically increasing index of refraction</span>
<span class="sd">    with negative depth.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_ice</span><span class="p">,</span> <span class="n">z_0</span><span class="p">,</span> <span class="n">delta_n</span> <span class="o">=</span> <span class="n">ice_params</span>

    <span class="k">def</span> <span class="nf">diff_n_ice</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>

        <span class="n">rel_diff</span> <span class="o">=</span> <span class="mf">2e-5</span>
        <span class="k">return</span> <span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="n">z_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_ice</span> <span class="o">-</span> <span class="n">rel_diff</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">diff_n_ice</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ray_tracing_2D"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D">[docs]</a><span class="k">class</span> <span class="nc">ray_tracing_2D</span><span class="p">(</span><span class="n">ray_tracing_base</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">medium</span><span class="p">,</span> <span class="n">attenuation_model</span><span class="o">=</span><span class="s2">&quot;SP1&quot;</span><span class="p">,</span>
                 <span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
                 <span class="n">n_frequencies_integration</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                 <span class="n">use_optimized_start_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialize 2D analytic ray tracing class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        medium: NuRadioMC.utilities.medium class</span>
<span class="sd">            details of the medium</span>
<span class="sd">        attenuation_model: string</span>
<span class="sd">            specifies which attenuation model to use (default &#39;SP1&#39;)</span>
<span class="sd">        log_level: logging.loglevel object</span>
<span class="sd">            controls verbosity (default WARNING)</span>
<span class="sd">        n_frequencies_integration: int</span>
<span class="sd">            specifies for how many frequencies the signal attenuation is being calculated</span>
<span class="sd">        use_optimized_start_value: bool</span>
<span class="sd">            if True, the initial C_0 paramter (launch angle) is set to the ray that skims the surface</span>
<span class="sd">            (default: False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medium</span> <span class="o">=</span> <span class="n">medium</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="s2">&quot;reflection&quot;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">reflection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model</span> <span class="o">=</span> <span class="n">attenuation_model</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model</span> <span class="ow">in</span> <span class="n">attenuation_util</span><span class="o">.</span><span class="n">model_to_int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;attenuation model </span><span class="si">{}</span><span class="s2"> is not implemented&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model_int</span> <span class="o">=</span> <span class="n">attenuation_util</span><span class="o">.</span><span class="n">model_to_int</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ray_tracing_2D&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__n_frequencies_integration</span> <span class="o">=</span> <span class="n">n_frequencies_integration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__use_optimized_start_values</span> <span class="o">=</span> <span class="n">use_optimized_start_values</span>

<div class="viewcode-block" id="ray_tracing_2D.n"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.n">[docs]</a>    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        refractive index as a function of depth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span>
    <span class="c1">#     if(type(z) is float):</span>
    <span class="c1">#         if(z &gt; 0):</span>
    <span class="c1">#             return 1.</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             return res</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         res[z &gt; 0] = 1.</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_gamma"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_gamma">[docs]</a>    <span class="k">def</span> <span class="nf">get_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        transforms z coordinate into gamma</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_turning_point"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_turning_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate the turning point, i.e. the maximum of the ray tracing path;</span>
<span class="sd">        parameter is c = self.medium.n_ice ** 2 - C_0 ** -2</span>

<span class="sd">        This is either the point of reflection off the ice surface</span>
<span class="sd">        or the point where the saddle point of the ray (transition from upward to downward going)</span>

<span class="sd">        Technically, the turning point is set to z=0 if the saddle point is above the surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c: float</span>
<span class="sd">            related to C_0 parameter via c = self.medium.n_ice ** 2 - C_0 ** -2</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        typle (gamma, z coordinate of turning point)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gamma2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>  <span class="c1"># first solution discarded</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span>

        <span class="k">if</span><span class="p">(</span><span class="n">z2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># a reflection is just a turning point at z = 0, i.e. cases 2) and 3) are the same</span>
            <span class="n">gamma2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gamma2</span><span class="p">,</span> <span class="n">z2</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_y_turn"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_y_turn">[docs]</a>    <span class="k">def</span> <span class="nf">get_y_turn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the y-coordinate of the turning point. This is either the point of reflection off the ice surface</span>
<span class="sd">        or the point where the saddle point of the ray (transition from upward to downward going)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 parameter of function</span>
<span class="sd">        x1: typle</span>
<span class="sd">            (y, z) start position of ray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_turn</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_C_1"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_C_1">[docs]</a>    <span class="k">def</span> <span class="nf">get_C_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates constant C_1 for a given C_0 and start point x1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_c"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_c">[docs]</a>    <span class="k">def</span> <span class="nf">get_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_C0_from_log"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_C0_from_log">[docs]</a>    <span class="k">def</span> <span class="nf">get_C0_from_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logC0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        transforms the fit parameter C_0 so that the likelihood looks better</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logC0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_y"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_y">[docs]</a>    <span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        analytic form of the ray tracing part given an exponential index of refraction profile</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gamma: (float or array)</span>
<span class="sd">            gamma is a function of the depth z</span>
<span class="sd">        C_0: (float)</span>
<span class="sd">            first parameter</span>
<span class="sd">        C_1: (float)</span>
<span class="sd">            second parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="c1"># we take the absolute number here but we only evaluate the equation for</span>
        <span class="c1"># positive outcome. This is to prevent rounding errors making the root</span>
        <span class="c1"># negative</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gamma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">logargument</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">logargument</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;log = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logargument</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">C_0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logargument</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_1</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_y_diff"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_y_diff">[docs]</a>    <span class="k">def</span> <span class="nf">get_y_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_raw</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        derivative dy(z)/dz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_unmirrored</span><span class="p">(</span><span class="n">z_raw</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">**</span>
                                          <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">C_0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1</span> <span class="o">+</span> <span class="n">E2</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">+</span> <span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span>
                                                                                                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">0.2e1</span> <span class="o">*</span> <span class="n">c</span> <span class="o">**</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span> <span class="o">*</span> <span class="n">E</span> <span class="o">**</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>

        <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">!=</span> <span class="n">z_raw</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_y_with_z_mirror"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_y_with_z_mirror">[docs]</a>    <span class="k">def</span> <span class="nf">get_y_with_z_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        analytic form of the ray tracing part given an exponential index of refraction profile</span>

<span class="sd">        this function automatically mirrors z values that are above the turning point,</span>
<span class="sd">        so that this function is defined for all z</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z: (float or array)</span>
<span class="sd">            depth z</span>
<span class="sd">        C_0: (float)</span>
<span class="sd">            first parameter</span>
<span class="sd">        C_1: (float)</span>
<span class="sd">            second parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_turn</span><span class="p">):</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_turn</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">zs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">res</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="n">zs</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;turning points for C_0 = </span><span class="si">{:.2f}</span><span class="s1">, b= </span><span class="si">{:.2f}</span><span class="s1">, gamma = </span><span class="si">{:.4f}</span><span class="s1">, z = </span><span class="si">{:.1f}</span><span class="s1">, y_turn = </span><span class="si">{:.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">C_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span><span class="p">,</span> <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span><span class="p">,</span> <span class="n">y_turn</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">zs</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_z_mirrored"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_z_mirrored">[docs]</a>    <span class="k">def</span> <span class="nf">get_z_mirrored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the mirrored x2 position so that y(z) can be used as a continuous function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="n">zstart</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zstop</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y_turn</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">zstop</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_turn</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_turn</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">x2_mirrored</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zstop</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x2_mirrored</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_z_unmirrored"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_z_unmirrored">[docs]</a>    <span class="k">def</span> <span class="nf">get_z_unmirrored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the unmirrored z position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">z_unmirrored</span> <span class="o">=</span> <span class="n">z</span>
        <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">z_turn</span><span class="p">):</span>
            <span class="n">z_unmirrored</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span>
        <span class="k">return</span> <span class="n">z_unmirrored</span></div>

<div class="viewcode-block" id="ray_tracing_2D.ds"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.ds">[docs]</a>    <span class="k">def</span> <span class="nf">ds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper to calculate line integral</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_y_diff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_path_length"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># we can only integrate upward going rays, so if the ray starts downwardgoing, we need to mirror</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="n">x1t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">x2t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x1t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x2t</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x1t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
            <span class="n">x2_mirrored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_mirrored</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_turn</span> <span class="ow">and</span> <span class="n">z_turn</span> <span class="o">&lt;</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_turn</span><span class="p">]</span>
            <span class="n">path_length</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">C_0</span><span class="p">),</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.49e-08</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;calculating path length (</span><span class="si">{}</span><span class="s2">) from (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) to (</span><span class="si">{:.2f}</span><span class="s2">, </span><span class="si">{:.2f}</span><span class="s2">) = (</span><span class="si">{:.2f}</span><span class="s2">, </span><span class="si">{:.2f}</span><span class="s2">) = </span><span class="si">{:.2f}</span><span class="s2"> m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solution_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                                                                                                        <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                                                                                        <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                                                                                                        <span class="n">path_length</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">path_length</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_path_length_analytic"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_path_length_analytic">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_length_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        analytic solution to calculate the distance along the path. This code is based on the analytic solution found</span>
<span class="sd">        by Ben Hokanson-Fasing and the pyrex implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># we can only integrate upward going rays, so if the ray starts downwardgoing, we need to mirror</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="n">x1t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">x2t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x1t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x2t</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x1t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="n">solution_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>

            <span class="n">z_deep</span> <span class="o">=</span> <span class="n">get_z_deep</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">))</span>
            <span class="n">launch_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">launch_angle</span><span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1">#         print(&quot;launchangle {:.1f} beta {:.2g} alpha {:.2g}, n(z1) = {:.2g} n(z2) = {:.2g}&quot;.format(launch_angle/units.deg, beta, alpha, self.n(x1[1]), self.n(x2[1])))</span>

            <span class="k">def</span> <span class="nf">l1</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="k">def</span> <span class="nf">l2</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="k">def</span> <span class="nf">get_s</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">deep</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="n">alpha</span> <span class="o">**</span> <span class="mf">0.5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#                 print(z, self.n(z), beta)</span>
                    <span class="c1">#                 print(alpha**0.5, l1(z), l2(z))</span>

                    <span class="n">path_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">/</span> <span class="n">alpha</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">z</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l1</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l2</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">path_length</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">or</span> <span class="n">path_length</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
                        <span class="n">path_length</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;analytic calculation travel time failed for x1 = </span><span class="si">{</span><span class="n">x1</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x2</span><span class="si">}</span><span class="s2"> and C0 = </span><span class="si">{</span><span class="n">C_0</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">return</span> <span class="n">path_length</span>

            <span class="k">def</span> <span class="nf">get_path_direct</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">):</span>
                <span class="n">int1</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span>
                <span class="n">int2</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">int1</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">int2</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
    <span class="c1">#             print(&#39;analytic {:.4g} ({:.0f} - {:.0f}={:.4g}, {:.4g})&#39;.format(</span>
    <span class="c1">#                 int2 - int1, get_s(x2[1]), x1[1], x2[1], get_s(x1[1])))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">z2</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">):</span>
                    <span class="c1"># z0 and z1 on same side of z_deep</span>
                    <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">int_diff</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z_deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z_deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z2</span><span class="p">:</span>
                        <span class="c1"># z0 below z_deep, z1 above z_deep</span>
                        <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span> <span class="o">+</span> <span class="n">int_diff</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># print(&quot;path:&quot;, int2 - int1 - int_diff)</span>
                        <span class="c1"># z0 above z_deep, z1 below z_deep</span>
                        <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span> <span class="o">-</span> <span class="n">int_diff</span>

            <span class="k">if</span><span class="p">(</span><span class="n">solution_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="n">get_path_direct</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">solution_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">z_turn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1">#             print(&#39;solution type {:d}, zturn = {:.1f}&#39;.format(solution_type, z_turn))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="n">get_path_direct</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_turn</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_path_direct</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_turn</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_travel_time"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_travel_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_travel_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># we can only integrate upward going rays, so if the ray starts downwardgoing, we need to mirror</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="n">x1t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">x2t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x1t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x2t</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x1t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="n">x2_mirrored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_mirrored</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_unmirrored</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_turn</span> <span class="ow">and</span> <span class="n">z_turn</span> <span class="o">&lt;</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_turn</span><span class="p">]</span>
            <span class="n">travel_time</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">C_0</span><span class="p">),</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.49e-08</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;calculating travel time from (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) to (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) = (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) = </span><span class="si">{:.2f}</span><span class="s2"> ns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">travel_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">ns</span><span class="p">))</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">travel_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_travel_time_analytic"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_travel_time_analytic">[docs]</a>    <span class="k">def</span> <span class="nf">get_travel_time_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        analytic solution to calculate the time of flight. This code is based on the analytic solution found</span>
<span class="sd">        by Ben Hokanson-Fasing and the pyrex implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># we can only integrate upward going rays, so if the ray starts downwardgoing, we need to mirror</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="n">x1t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">x2t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x1t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x2t</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x1t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="n">solution_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>

            <span class="n">z_deep</span> <span class="o">=</span> <span class="n">get_z_deep</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">))</span>
            <span class="n">launch_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">launch_angle</span><span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1">#         print(&quot;launchangle {:.1f} beta {:.2g} alpha {:.2g}, n(z1) = {:.2g} n(z2) = {:.2g}&quot;.format(launch_angle/units.deg, beta, alpha, self.n(x1[1]), self.n(x2[1])))</span>

            <span class="k">def</span> <span class="nf">l1</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="k">def</span> <span class="nf">l2</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="k">def</span> <span class="nf">get_s</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">deep</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span> <span class="o">*</span> <span class="n">speed_of_light</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                    <span class="n">log_1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">log_2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">log_2</span><span class="p">)</span> <span class="o">+</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">log_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">)</span> <span class="o">-</span>
                            <span class="n">z</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">speed_of_light</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;analytic calculation travel time failed for x1 = </span><span class="si">{</span><span class="n">x1</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x2</span><span class="si">}</span><span class="s2"> and C0 = </span><span class="si">{</span><span class="n">C_0</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="k">return</span> <span class="n">s</span>

            <span class="k">def</span> <span class="nf">get_ToF_direct</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">):</span>
                <span class="n">int1</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span>
                <span class="n">int2</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">int1</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">int2</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
    <span class="c1">#             print(&#39;analytic {:.4g} ({:.0f} - {:.0f}={:.4g}, {:.4g})&#39;.format(</span>
    <span class="c1">#                 int2 - int1, get_s(x2[1]), x1[1], x2[1], get_s(x1[1])))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">z2</span> <span class="o">&lt;</span> <span class="n">z_deep</span><span class="p">):</span>
                    <span class="c1"># z0 and z1 on same side of z_deep</span>
                    <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">int_diff</span> <span class="o">=</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z_deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">get_s</span><span class="p">(</span><span class="n">z_deep</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">z1</span> <span class="o">&lt;</span> <span class="n">z2</span><span class="p">:</span>
                        <span class="c1"># z0 below z_deep, z1 above z_deep</span>
                        <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span> <span class="o">+</span> <span class="n">int_diff</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># z0 above z_deep, z1 below z_deep</span>
                        <span class="k">return</span> <span class="n">int2</span> <span class="o">-</span> <span class="n">int1</span> <span class="o">-</span> <span class="n">int_diff</span>

            <span class="k">if</span><span class="p">(</span><span class="n">solution_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ttmp</span> <span class="o">=</span> <span class="n">get_ToF_direct</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="n">ttmp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;calculating travel time from (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) to (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) = </span><span class="si">{:.2f}</span><span class="s2"> ns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ttmp</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">ns</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">solution_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">z_turn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1">#             print(&#39;solution type {:d}, zturn = {:.1f}&#39;.format(solution_type, z_turn))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ttmp</span> <span class="o">=</span> <span class="n">get_ToF_direct</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_turn</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_ToF_direct</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_turn</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="n">ttmp</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;calculating travel time from (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) to (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) = </span><span class="si">{:.2f}</span><span class="s2"> ns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ttmp</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">ns</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

    <span class="k">def</span> <span class="nf">__get_frequencies_for_attenuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">nfreqs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_frequencies_integration</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">frequency</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">nfreqs</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nfreqs</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">and</span> <span class="n">max_detector_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">mask2</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">&lt;=</span> <span class="n">max_detector_freq</span>
                <span class="n">nfreqs2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__n_frequencies_integration</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask2</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
                <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="n">mask2</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">frequency</span><span class="p">[</span><span class="n">mask2</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">nfreqs2</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">mask2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="o">~</span><span class="n">mask2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">frequency</span><span class="p">[</span><span class="o">~</span><span class="n">mask2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">nfreqs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;calculating attenuation for frequencies </span><span class="si">{</span><span class="n">freqs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">freqs</span>

<div class="viewcode-block" id="ray_tracing_2D.get_attenuation_along_path"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_attenuation_along_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_attenuation_along_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tmp_attenuation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">output</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;calculating attenuation for n_ref = </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">reflection</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">: &quot;</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># we can only integrate upward going rays, so if the ray starts downwardgoing, we need to mirror</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="n">x1t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">x2t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
                <span class="n">x1t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x2t</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x1t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>

            <span class="k">if</span><span class="p">(</span><span class="n">cpp_available</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_frequencies_for_attenuation</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">get_attenuation_along_path</span><span class="p">(</span>
                        <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model_int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="n">attenuation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
                <span class="n">attenuation</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">x2_mirrored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_mirrored</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_unmirrored</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">attenuation_util</span><span class="o">.</span><span class="n">get_attenuation_length</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_model</span><span class="p">)</span>

                <span class="c1"># to speed up things we only calculate the attenuation for a few frequencies</span>
                <span class="c1"># and interpolate linearly between them</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_frequencies_for_attenuation</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="p">)</span>
                <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_turn</span> <span class="ow">and</span> <span class="n">z_turn</span> <span class="o">&lt;</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">z_turn</span><span class="p">]</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">C_0</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">])</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="c1">#         tmp = np.array([integrate.quad(dt, x1[1], x2_mirrored[1], args=(C_0, f), epsrel=0.05)[0] for f in frequency[mask]])</span>
                <span class="n">attenuation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
                <span class="n">attenuation</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;calculating attenuation from (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) to (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) = (</span><span class="si">{:.0f}</span><span class="s2">, </span><span class="si">{:.0f}</span><span class="s2">) =  a factor </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2_mirrored</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">attenuation</span><span class="p">))</span>
            <span class="n">iF</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;adding attenuation for path segment </span><span class="si">{</span><span class="n">iS</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">attenuation</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span><span class="si">:</span><span class="s2">.2g</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">frequency</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span><span class="o">/</span><span class="n">units</span><span class="o">.</span><span class="n">MHz</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> MHz, &quot;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">tmp_attenuation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">tmp_attenuation</span> <span class="o">=</span> <span class="n">attenuation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_attenuation</span> <span class="o">*=</span> <span class="n">attenuation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp_attenuation</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_path_segments"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_path_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the different segments of the path that makes up the full ray tracing path</span>
<span class="sd">        One segment per bottom reflection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: tuple</span>
<span class="sd">            (y, z) coordinate of start value</span>
<span class="sd">        x2: tuple</span>
<span class="sd">            (y, z) coordinate of stop value</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 parameter of analytic ray path function</span>
<span class="sd">        reflection: int (default 0)</span>
<span class="sd">            the number of bottom reflections to consider</span>
<span class="sd">        reflection_case: int (default 1)</span>
<span class="sd">            only relevant if `reflection` is larger than 0</span>

<span class="sd">            * 1: rays start upwards</span>
<span class="sd">            * 2: rays start downwards</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        (original x1, x1 of path segment, original x2, x2 of path segment, C_0, C_1 of path segment)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x11</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x22</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="n">reflection</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">C_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">]]</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span><span class="p">(</span><span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># the code only allows upward going rays, thus we find a point left from x1 that has an upward going ray</span>
            <span class="c1"># that will produce a downward going ray through x1</span>
            <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_turn</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;relaction case 2: shifting x1 </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reflection</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;calculation path for reflection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">C_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reflection_point</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="n">stop_loop</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x22</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">stop_loop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x22</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">])</span>
            <span class="k">if</span><span class="p">(</span><span class="n">stop_loop</span><span class="p">):</span>
                <span class="k">break</span>
<span class="c1">#             yyy, zzz = self.get_path(x1, x2, C_0, n_points)</span>
<span class="c1">#             yy.extend(yyy)</span>
<span class="c1">#             zz.extend(zzz)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setting x1 from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x_start</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the angle with respect to the positive z-axis of the ray path at position x</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: tuple</span>
<span class="sd">            (y, z) coordinate to calculate the angle</span>
<span class="sd">        x_start: tuple</span>
<span class="sd">            (y, z) start position of the ray</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 parameter of analytic ray path function</span>
<span class="sd">        reflection: int (default 0)</span>
<span class="sd">            the number of bottom reflections to consider</span>
<span class="sd">        reflection_case: int (default 1)</span>
<span class="sd">            only relevant if `reflection` is larger than 0</span>

<span class="sd">            * 1: rays start upwards</span>
<span class="sd">            * 2: rays start downwards</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x_start</span> <span class="o">=</span> <span class="n">last_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_mirrored</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_diff</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">angle</span>
        <span class="k">return</span> <span class="n">angle</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_launch_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_launch_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_launch_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_receive_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_receive_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_receive_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_reflection_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_reflection_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_reflection_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the angle under which the ray reflects off the surface. If not reflection occurs, None is returned</span>

<span class="sd">        If reflections off the bottom (e.g. Moore&#39;s Bay) are simulated, an array with reflection angles (one for</span>
<span class="sd">        each track segment) is returned</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: tuple</span>
<span class="sd">            (y, z) start position of ray</span>
<span class="sd">        x2: tuple</span>
<span class="sd">            (y, z) stop position of the ray</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 parameter of analytic ray path function</span>
<span class="sd">        reflection: int (default 0)</span>
<span class="sd">            the number of bottom reflections to consider</span>
<span class="sd">        reflection_case: int (default 1)</span>
<span class="sd">            only relevant if `reflection` is larger than 0</span>
<span class="sd">            * 1: rays start upwards</span>
<span class="sd">            * 2: rays start downwards</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_segments</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">):</span>
            <span class="n">x11</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span> <span class="o">=</span> <span class="n">segment</span>
            <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_turn</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="k">if</span><span class="p">((</span><span class="n">z_turn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y_turn</span> <span class="o">&gt;</span> <span class="n">x11</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y_turn</span> <span class="o">&lt;</span> <span class="n">x22</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># for the first track segment we need to check if turning point is right of start point (otherwise we have a downward going ray that does not have a turning point), and for the last track segment we need to check that the turning point is left of the stop position.</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_turn</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;reflecting off surface at y = </span><span class="si">{:.1f}</span><span class="s2">m, reflection angle = </span><span class="si">{:.1f}</span><span class="s2">deg&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y_turn</span><span class="p">,</span> <span class="n">r</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_path"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for plotting purposes only, returns the ray tracing path between x1 and x2</span>

<span class="sd">        the result is only valid if C_0 is a solution to the ray tracing problem</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: array</span>
<span class="sd">            start position (y, z)</span>
<span class="sd">        x2: array</span>
<span class="sd">            stop position (y, z)</span>
<span class="sd">        C_0: (float)</span>
<span class="sd">            first parameter</span>
<span class="sd">        n_points: integer (optional)</span>
<span class="sd">            the number of coordinates to calculate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yy: array</span>
<span class="sd">            the y coordinates of the ray tracing path</span>
<span class="sd">        zz: array</span>
<span class="sd">            the z coordinates of the ray tracing path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="n">zstart</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_mirrored</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">zstart</span><span class="p">,</span> <span class="n">zstop</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_turn</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">zs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">res</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="n">zs</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;turning points for C_0 = </span><span class="si">{:.2f}</span><span class="s1">, b= </span><span class="si">{:.2f}</span><span class="s1">, gamma = </span><span class="si">{:.4f}</span><span class="s1">, z = </span><span class="si">{:.1f}</span><span class="s1">, y_turn = </span><span class="si">{:.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">C_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__b</span><span class="p">,</span> <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span><span class="p">,</span> <span class="n">y_turn</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">zs</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_path_reflections"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_path_reflections">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_reflections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the ray path in the presence of reflections at the bottom</span>
<span class="sd">        The full path is constructed by multiple calls to the `get_path()` function to put together the full path</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: tuple</span>
<span class="sd">            (y, z) coordinate of start value</span>
<span class="sd">        x2: tuple</span>
<span class="sd">            (y, z) coordinate of stop value</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 parameter of analytic ray path function</span>
<span class="sd">        n_points: int (default 1000)</span>
<span class="sd">            the number of points of the numeric path</span>
<span class="sd">        reflection: int (default 0)</span>
<span class="sd">            the number of bottom reflections to consider</span>
<span class="sd">        reflection_case: int (default 1)</span>
<span class="sd">            only relevant if `reflection` is larger than 0</span>

<span class="sd">            * 1: rays start upwards</span>
<span class="sd">            * 2: rays start downwards</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yy: array</span>
<span class="sd">            the y coordinates of the ray tracing path</span>
<span class="sd">        zz: array</span>
<span class="sd">            the z coordinates of the ray tracing path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x11</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="n">reflection</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># the code only allows upward going rays, thus we find a point left from x1 that has an upward going ray</span>
            <span class="c1"># that will produce a downward going ray through x1</span>
            <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_turn</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;relaction case 2: shifting x1 </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span>

        <span class="k">if</span><span class="p">(</span><span class="n">reflection</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># in case of no bottom reflections, return path right away</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">x22</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reflection</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;calculation path for reflection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reflection_point</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x22</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">x22</span>
            <span class="n">yyy</span><span class="p">,</span> <span class="n">zzz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
            <span class="n">yy</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">yyy</span><span class="p">)</span>
            <span class="n">zz</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">zzz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setting x1 from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span>

        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">&gt;</span> <span class="n">x11</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">yy</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">zz</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_reflection_point"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_reflection_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_reflection_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the point where the signal gets reflected off the bottom of the ice shelf</span>

<span class="sd">        Returns tuple (y,z)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">reflection</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="o">-</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x2</span></div>

<div class="viewcode-block" id="ray_tracing_2D.obj_delta_y_square"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.obj_delta_y_square">[docs]</a>    <span class="k">def</span> <span class="nf">obj_delta_y_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logC_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        objective function to find solution for C0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">logC_0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delta_y</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="n">reflection_case</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="ray_tracing_2D.obj_delta_y"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.obj_delta_y">[docs]</a>    <span class="k">def</span> <span class="nf">obj_delta_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logC_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        function to find solution for C0, returns distance in y between function and x2 position</span>
<span class="sd">        result is signed! (important to use a root finder)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">logC_0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delta_y</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="n">reflection_case</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_delta_y"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_delta_y">[docs]</a>    <span class="k">def</span> <span class="nf">get_delta_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C0range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the difference in the y position between the analytic ray tracing path</span>
<span class="sd">        specified by C_0 at the position x2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">C0range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">C0range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
            <span class="n">C_0</span> <span class="o">=</span> <span class="n">C_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span><span class="p">((</span><span class="n">C_0</span> <span class="o">&lt;</span> <span class="n">C0range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span><span class="p">(</span><span class="n">C_0</span> <span class="o">&gt;</span> <span class="n">C0range</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;C0 = </span><span class="si">{:.4f}</span><span class="s1"> out of range </span><span class="si">{:.0f}</span><span class="s1"> - </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C0range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C0range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>

        <span class="c1"># we consider two cases here,</span>
        <span class="c1"># 1) the rays start rising -&gt; the default case</span>
        <span class="c1"># 2) the rays start decreasing -&gt; we need to find the position left of the start point that</span>
        <span class="c1">#    that has rising rays that go through the point x1</span>
        <span class="k">if</span><span class="p">(</span><span class="n">reflection</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reflection_case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_turn</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;relaction case 2: shifting x1 </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reflection</span><span class="p">):</span>
            <span class="c1"># we take account reflections at the bottom layer into account via</span>
            <span class="c1"># 1) calculating the point where the reflection happens</span>
            <span class="c1"># 2) starting a ray tracing from this new point</span>

            <span class="c1"># determine y translation first</span>
            <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">C_1</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
                <span class="n">C_1</span> <span class="o">=</span> <span class="n">C_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;C_0 = </span><span class="si">{:.4f}</span><span class="s2">, C_1 = </span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reflection_point</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>

        <span class="c1"># determine y translation first</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">C_1</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
            <span class="n">C_1</span> <span class="o">=</span> <span class="n">C_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;C_0 = </span><span class="si">{:.4f}</span><span class="s2">, C_1 = </span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">))</span>

        <span class="c1"># for a given c_0, 3 cases are possible to reach the y position of x2</span>
        <span class="c1"># 1) direct ray, i.e., before the turning point</span>
        <span class="c1"># 2) refracted ray, i.e. after the turning point but not touching the surface</span>
        <span class="c1"># 3) reflected ray, i.e. after the ray reaches the surface</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">z_turn</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>  <span class="c1"># turning points is deeper that x2 positions, can&#39;t reach target</span>
            <span class="c1"># the minimizer has problems finding the minimum if inf is returned here. Therefore, we return the distance</span>
            <span class="c1"># between the turning point and the target point + 10 x the distance between the z position of the turning points</span>
            <span class="c1"># and the target position. This results in a objective function that has the solutions as the only minima and</span>
            <span class="c1"># is smooth in C_0</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">((</span><span class="n">z_turn</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_turn</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_turn</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;turning points (zturn = </span><span class="si">{:.0f}</span><span class="s2"> is deeper than x2 positon z2 = </span><span class="si">{:.0f}</span><span class="s2">, setting distance to target position to </span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z_turn</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">diff</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">diff</span>
<span class="c1">#             return -np.inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;turning points is z = </span><span class="si">{:.1f}</span><span class="s1">, y =  </span><span class="si">{:.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z_turn</span><span class="p">,</span> <span class="n">y_turn</span><span class="p">))</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y_turn</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># we always propagate from left to right</span>
            <span class="c1"># direct ray</span>
            <span class="n">y2_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>  <span class="c1"># calculate y position at get_path position</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2_fit</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
                <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;we have a direct ray, y(</span><span class="si">{:.1f}</span><span class="s1">) = </span><span class="si">{:.1f}</span><span class="s1"> -&gt; </span><span class="si">{:.1f}</span><span class="s1"> away from </span><span class="si">{:.1f}</span><span class="s1">, turning point = y=</span><span class="si">{:.1f}</span><span class="s1">, z=</span><span class="si">{:.2f}</span><span class="s1">, x0 = </span><span class="si">{:.1f}</span><span class="s1"> </span><span class="si">{:.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y2_fit</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_turn</span><span class="p">,</span> <span class="n">z_turn</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">diff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># now it&#39;s a bit more complicated. we need to transform the coordinates to</span>
            <span class="c1"># be on the mirrored part of the function</span>
            <span class="n">z_mirrored</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z_mirrored</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_y( </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">))</span>
            <span class="n">y2_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
            <span class="n">y2_fit</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_turn</span> <span class="o">-</span> <span class="n">y2_raw</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2_fit</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;we have a reflected/refracted ray, y(</span><span class="si">{:.1f}</span><span class="s1">) = </span><span class="si">{:.1f}</span><span class="s1"> (</span><span class="si">{:.1f}</span><span class="s1">) -&gt; </span><span class="si">{:.1f}</span><span class="s1"> away from </span><span class="si">{:.1f}</span><span class="s1"> (gamma = </span><span class="si">{:.5g}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">z_mirrored</span><span class="p">,</span> <span class="n">y2_fit</span><span class="p">,</span> <span class="n">y2_raw</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gamma</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">diff</span></div>

<div class="viewcode-block" id="ray_tracing_2D.determine_solution_type"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.determine_solution_type">[docs]</a>    <span class="k">def</span> <span class="nf">determine_solution_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the type of the solution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: 2dim np.array</span>
<span class="sd">            start position</span>
<span class="sd">        x2: 2dim np.array</span>
<span class="sd">            stop position</span>
<span class="sd">        C_0: float</span>
<span class="sd">            C_0 value of ray tracing solution</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        solution_type: int</span>

<span class="sd">            * 1: &#39;direct&#39;</span>
<span class="sd">            * 2: &#39;refracted&#39;</span>
<span class="sd">            * 3: &#39;reflected</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C_0</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C_0</span><span class="p">)</span>
        <span class="n">gamma_turn</span><span class="p">,</span> <span class="n">z_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_turning_point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">y_turn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma_turn</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y_turn</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">solution_types_revert</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">z_turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">solution_types_revert</span><span class="p">[</span><span class="s1">&#39;reflected&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">solution_types_revert</span><span class="p">[</span><span class="s1">&#39;refracted&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="ray_tracing_2D.find_solutions"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.find_solutions">[docs]</a>    <span class="k">def</span> <span class="nf">find_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this function finds all ray tracing solutions</span>

<span class="sd">        prerequesite is that x2 is above and to the right of x1, this is not a violation of universality</span>
<span class="sd">        because this requirement can be achieved with a simple coordinate transformation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: tuple</span>
<span class="sd">            (y,z) coordinate of start point</span>
<span class="sd">        x2: tuple</span>
<span class="sd">            (y,z) coordinate of stop point</span>
<span class="sd">        reflection: int (default 0)</span>
<span class="sd">            how many reflections off the reflective layer (bottom of ice shelf) should be simulated</span>


<span class="sd">        returns an array of the C_0 paramters of the solutions (the array might be empty)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">reflection</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">reflection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;a solution for </span><span class="si">{:d}</span><span class="s2"> reflection(s) off the bottom reflective layer is requested, but ice model does not specify a reflective layer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reflection</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;a solution for </span><span class="si">{:d}</span><span class="s2"> reflection(s) off the bottom reflective layer is requested, but ice model does not specify a reflective layer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reflection</span><span class="p">))</span>

        <span class="k">if</span><span class="p">(</span><span class="n">cpp_available</span><span class="p">):</span>
            <span class="c1">#             t = time.time()</span>
<span class="c1">#             print(&quot;find solutions&quot;, x1, x2, self.medium.n_ice, self.medium.delta_n, self.medium.z_0, reflection, reflection_case, self.medium.reflection)</span>
            <span class="n">tmp_reflection</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">reflection</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">tmp_reflection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">tmp_reflection</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># this parameter will never be used but is required to be an into to be able to pass it to the C++ module, so set it to a positive number, i.e., a reflective layer above the ice</span>
            <span class="n">solutions</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">,</span> <span class="n">tmp_reflection</span><span class="p">)</span>
<span class="c1">#             print((time.time() -t)*1000.)</span>
            <span class="k">return</span> <span class="n">solutions</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">C0s</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># intermediate storage of results</span>

            <span class="c1"># calculate optimal start value. The objective function becomes infinity if the turning point is below the z</span>
            <span class="c1"># position of the observer. We calculate the corresponding value so that the minimization starts at one edge</span>
            <span class="c1"># of the objective function</span>
            <span class="c1"># c = self.__b ** 2 / 4 - (0.5 * self.__b - np.exp(x2[1] / self.medium.z_0) * self.medium.n_ice) ** 2</span>
            <span class="c1"># C_0_start = (1 / (self.medium.n_ice ** 2 - c)) ** 0.5</span>
            <span class="c1"># R.L. March 15, 2019: This initial condition does not find a solution for e.g.:</span>
            <span class="c1"># emitter  at [-400.0*units.m,-732.0*units.m], receiver at [0., -2.0*units.m]</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__use_optimized_start_values</span><span class="p">):</span>
                <span class="c1"># take surface skimming ray as start value</span>
                <span class="n">C_0_start</span><span class="p">,</span> <span class="n">th_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surf_skim_angle</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
                <span class="n">logC_0_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C_0_start</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;starting optimization with x0 = </span><span class="si">{:.2f}</span><span class="s1"> -&gt; C0 = </span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">logC_0_start</span><span class="p">,</span> <span class="n">C_0_start</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logC_0_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y_square</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">logC_0_start</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">),</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span> <span class="o">&lt;</span> <span class="mf">1e-7</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot_result</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">C0s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
                    <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">C0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_0</span><span class="p">)</span>
                    <span class="n">solution_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;found </span><span class="si">{}</span><span class="s2"> solution C0 = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solution_types</span><span class="p">[</span><span class="n">solution_type</span><span class="p">],</span> <span class="n">C_0</span><span class="p">))</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">solution_type</span><span class="p">,</span>
                                    <span class="s1">&#39;C0&#39;</span><span class="p">:</span> <span class="n">C_0</span><span class="p">,</span>
                                    <span class="s1">&#39;C1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">),</span>
                                    <span class="s1">&#39;reflection&#39;</span><span class="p">:</span> <span class="n">reflection</span><span class="p">,</span>
                                    <span class="s1">&#39;reflection_case&#39;</span><span class="p">:</span> <span class="n">reflection_case</span><span class="p">})</span>

            <span class="c1"># check if another solution with higher logC0 exists</span>
            <span class="n">logC0_start</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.0001</span>
            <span class="n">logC0_stop</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">delta_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">(</span><span class="n">logC0_start</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span>
            <span class="n">delta_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">(</span><span class="n">logC0_stop</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span>
        <span class="c1">#     print(logC0_start, logC0_stop, delta_start, delta_stop, np.sign(delta_start), np.sign(delta_stop))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_stop</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;solution with logC0 &gt; </span><span class="si">{:.3f}</span><span class="s2"> exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">result2</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">,</span> <span class="n">logC0_start</span><span class="p">,</span> <span class="n">logC0_stop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">))</span>
                <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot_result</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result2</span><span class="p">),</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">C0s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
                    <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
                    <span class="n">C0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_0</span><span class="p">)</span>
                    <span class="n">solution_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;found </span><span class="si">{}</span><span class="s2"> solution C0 = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solution_types</span><span class="p">[</span><span class="n">solution_type</span><span class="p">],</span> <span class="n">C_0</span><span class="p">))</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">solution_type</span><span class="p">,</span>
                                    <span class="s1">&#39;C0&#39;</span><span class="p">:</span> <span class="n">C_0</span><span class="p">,</span>
                                    <span class="s1">&#39;C1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">),</span>
                                    <span class="s1">&#39;reflection&#39;</span><span class="p">:</span> <span class="n">reflection</span><span class="p">,</span>
                                    <span class="s1">&#39;reflection_case&#39;</span><span class="p">:</span> <span class="n">reflection_case</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no solution with logC0 &gt; </span><span class="si">{:.3f}</span><span class="s2"> exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">logC0_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
            <span class="n">logC0_stop</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.0001</span>
            <span class="n">delta_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">(</span><span class="n">logC0_start</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span>
            <span class="n">delta_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">(</span><span class="n">logC0_stop</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">)</span>
        <span class="c1">#     print(logC0_start, logC0_stop, delta_start, delta_stop, np.sign(delta_start), np.sign(delta_stop))</span>
            <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_stop</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;solution with logC0 &lt; </span><span class="si">{:.3f}</span><span class="s2"> exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">result3</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_delta_y</span><span class="p">,</span> <span class="n">logC0_start</span><span class="p">,</span> <span class="n">logC0_stop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">reflection</span><span class="p">,</span> <span class="n">reflection_case</span><span class="p">))</span>

                <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot_result</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result3</span><span class="p">),</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">C0s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
                    <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result3</span><span class="p">)</span>
                    <span class="n">C0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_0</span><span class="p">)</span>
                    <span class="n">solution_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;found </span><span class="si">{}</span><span class="s2"> solution C0 = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solution_types</span><span class="p">[</span><span class="n">solution_type</span><span class="p">],</span> <span class="n">C_0</span><span class="p">))</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">solution_type</span><span class="p">,</span>
                                    <span class="s1">&#39;C0&#39;</span><span class="p">:</span> <span class="n">C_0</span><span class="p">,</span>
                                    <span class="s1">&#39;C1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">),</span>
                                    <span class="s1">&#39;reflection&#39;</span><span class="p">:</span> <span class="n">reflection</span><span class="p">,</span>
                                    <span class="s1">&#39;reflection_case&#39;</span><span class="p">:</span> <span class="n">reflection_case</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no solution with logC0 &lt; </span><span class="si">{:.3f}</span><span class="s2"> exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="ray_tracing_2D.plot_result"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.plot_result">[docs]</a>    <span class="k">def</span> <span class="nf">plot_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper function to visualize results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>

        <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_with_z_mirror</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">C_1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;C0 = </span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">C_0</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1">#     ax.plot(zz, yy, &#39;-&#39;, label=&#39;C0 = {:.3f}&#39;.format(C_0))</span>
    <span class="c1">#     ax.plot(x1[1], x1[0], &#39;ko&#39;)</span>
    <span class="c1">#     ax.plot(x2[1], x2[0], &#39;d&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_angle_from_C_0"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_angle_from_C_0">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle_from_C_0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_0</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">,</span> <span class="n">angoff</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">logC_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C_0</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_angle_from_logC_0</span><span class="p">(</span><span class="n">logC_0</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">,</span> <span class="n">angoff</span><span class="p">)</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_angle_from_logC_0"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_angle_from_logC_0">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle_from_logC_0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logC_0</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">,</span> <span class="n">angoff</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        argument angoff is provided so that the function can be used for minimization in get_C_0_from_angle(),</span>
<span class="sd">        in which case angoff is the angle for which the C_0 is sought and zero is returned when it is found.</span>

<span class="sd">        C_0 has a smallest possible value at 1./self.medium.n_ice . When it approaches this value, very</span>
<span class="sd">        small changes in C_0 correspond to a given change in the angle. In order to prevent the root finding</span>
<span class="sd">        algorithm from crossing into the invalid range of C_0 at values smaller than 1./self.medium.n_ice,</span>
<span class="sd">        the root finding is done with the parameter logC_0 = np.log(C_0 - 1. / self.medium.n_ice), so it is</span>
<span class="sd">        not exactly the log of C_0 as the nome of this method implies.</span>
<span class="sd">        This is the same parameter transformation that is done for find_solutions()</span>

<span class="sd">        input:</span>
<span class="sd">            logC_0 = np.log(C_0 - 1. / self.medium.n_ice)</span>
<span class="sd">            angoff = angular offset</span>
<span class="sd">            z_pos  = z-position from where ray is emitted</span>
<span class="sd">        output:</span>
<span class="sd">            angle corresponding to C_0, minus offset angoff</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">C_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">logC_0</span><span class="p">)</span>

        <span class="n">dydz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_diff</span><span class="p">(</span><span class="n">z_pos</span><span class="p">,</span> <span class="n">C_0</span><span class="p">)</span>
<span class="c1">#        dydz = self.get_dydz_analytic(C_0, z_pos)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dydz</span><span class="p">)</span>

        <span class="c1"># print(dydz,angoffdydz)</span>

        <span class="k">return</span> <span class="n">angle</span> <span class="o">-</span> <span class="n">angoff</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_C_0_from_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_C_0_from_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_C_0_from_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anglaunch</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Find parameter C0 corresponding to a given launch angle and z-position of a ray.</span>
<span class="sd">        The parameter is found by means of a root finding procedure</span>

<span class="sd">        output:</span>
<span class="sd">            Complete output of optimisation procedure</span>
<span class="sd">            (result.x[0] is the C0 value found by optimisation procedure)</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># C_0 has a smallest possible value at 1./self.medium.n_ice . When it approaches this value, very</span>
        <span class="c1"># small changes in C_0 correspond to given change in the angle. In order to prevent the root finding</span>
        <span class="c1"># algorithm to cross into the invalid range of C_0 at  values smaller than 1./self.medium.n_ice,</span>
        <span class="c1"># the root finding is done with the parameter logC_0_start below. This is the same parameter transformation</span>
        <span class="c1"># that is done for find_solutions()</span>

        <span class="n">C_0_start</span> <span class="o">=</span> <span class="mf">2.</span>

        <span class="n">logC_0_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C_0_start</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span><span class="p">)</span>

<span class="c1">#        result = optimize.root(self.get_angle_from_C_0,np.pi/4.,args=(z_pos,anglaunch))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_angle_from_logC_0</span><span class="p">,</span> <span class="n">logC_0_start</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">z_pos</span><span class="p">,</span> <span class="n">anglaunch</span><span class="p">))</span>

        <span class="c1"># want to return the complete instance of the result class; result value result.x[0] is logC_0,</span>
        <span class="c1"># but we want C_0, so replace it in the result class. This may not be good practice but it seems to be</span>
        <span class="c1"># more user-friendly than to return the value logC_0</span>
        <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_C0_from_log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">result</span></div>

<span class="c1">#     def get_dydz_analytic(self, C_0, z_pos):</span>
<span class="c1">#         &#39;&#39;&#39;</span>
<span class="c1">#         Implementation of derivative dy/dz obtained from the analytic expresion for y(z)</span>
<span class="c1">#         Returns dy/dz for a given z-position and C_0</span>
<span class="c1">#         &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#         gamma = self.get_gamma(z_pos)</span>
<span class="c1">#</span>
<span class="c1">#         b = self.__b</span>
<span class="c1">#         c = self.medium.n_ice ** 2 - C_0 ** -2</span>
<span class="c1">#         root = np.abs(gamma ** 2 - gamma * b + c)</span>
<span class="c1">#         logargument = gamma / (2 * c ** 0.5 * (root) ** 0.5 - b * gamma + 2 * c)</span>
<span class="c1">#</span>
<span class="c1">#         dydz = 1/(C_0*np.sqrt(c))*(1 - np.sqrt(c)/np.sqrt(root)*(2*gamma-b)*logargument + b*logargument)</span>
<span class="c1">#</span>
<span class="c1">#         return dydz</span>

<div class="viewcode-block" id="ray_tracing_2D.get_z_from_n"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_z_from_n">[docs]</a>    <span class="k">def</span> <span class="nf">get_z_from_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        get z from given n - equation from get_n solved for z</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_surf_skim_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_surf_skim_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_surf_skim_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For a given position x1 = [x,z] and depth profile self.n(), find the angle at which a beam must be</span>
<span class="sd">        emitted to &quot;skim the surface&quot;, i.e. arrive horizontally (angle = 90 deg) at the surface;</span>
<span class="sd">        This is used to find the refraction zone.</span>

<span class="sd">        returns:</span>
<span class="sd">            C0crit: C0 of critical angle</span>
<span class="sd">            thcrit: critical angle</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">nlaunch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># by definition, z of critical angle is at surface, i.e. z=0</span>
        <span class="n">zcrit</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">nsurf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">zcrit</span><span class="p">)</span>

        <span class="n">sinthcrit</span> <span class="o">=</span> <span class="n">nsurf</span> <span class="o">/</span> <span class="n">nlaunch</span>
        <span class="k">if</span> <span class="n">sinthcrit</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># ray goes from point with high optical thickness to point with lower optical thickness,</span>
            <span class="c1"># i.e. ray bending is towards horizontal</span>
            <span class="n">thcrit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">sinthcrit</span><span class="p">)</span>
            <span class="n">C0result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_0_from_angle</span><span class="p">(</span><span class="n">thcrit</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">C0crit</span> <span class="o">=</span> <span class="n">C0result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ray goes from point with low optical thickness to point with higher optical thickness,</span>
            <span class="c1"># i.e. ray bending is towards vertical, no solution</span>
            <span class="n">thcrit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">C0crit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; No solution for critical angle for z = </span><span class="si">{}</span><span class="s1">!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; critical angle for z = </span><span class="si">{}</span><span class="s1"> is </span><span class="si">{}</span><span class="s1"> !&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">thcrit</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; C0 for critical angle is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">C0crit</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">C0crit</span><span class="p">,</span> <span class="n">thcrit</span></div>

<div class="viewcode-block" id="ray_tracing_2D.is_in_refraction_zone"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.is_in_refraction_zone">[docs]</a>    <span class="k">def</span> <span class="nf">is_in_refraction_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">C0crit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Find if receiver at x2 is in the refraction zone of emitter at x1. The refraction zone</span>
<span class="sd">        is the oposite of the shadow zone.</span>

<span class="sd">        If the C0 of the critical angle, C0crit, is provided, it will not be calculated. This is useful</span>
<span class="sd">        in case find_solutions() is called and C0crit is calculated in the process of determining the</span>
<span class="sd">        initial value for the minimization procedure.</span>

<span class="sd">        Returns True if x2 is in the refraction zone of x1 - note that the inverse statement is not</span>
<span class="sd">        necessarily true, i.e. when False is returned, it is possible that x2 is in the refraction</span>
<span class="sd">        zone nonetheless</span>

<span class="sd">        TODO:</span>
<span class="sd">        Why does the reference point not seem to lie exactly on the mirrored path?</span>
<span class="sd">        Instead of returning True/False, it might be useful to return  ycheck - x2[0] (in case x2[0]&gt;ycrit),</span>
<span class="sd">        which gives some idea of how close the receiver is to the refraction zone. This could be used to</span>
<span class="sd">        define a &quot;gray zone&#39; and a &#39;far zone&#39;, in which the receiver is most definitely in the shadow zone</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">refraction</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">C0crit</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C0crit</span><span class="p">,</span> <span class="n">thcrit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surf_skim_angle</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="c1"># z_crit = 0 and hence gamma_crit = delta_n by definition</span>
        <span class="n">gcrit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span>
        <span class="c1"># the y-value where the ray hits z=0</span>
        <span class="n">ycrit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gcrit</span><span class="p">,</span> <span class="n">C0crit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">C0crit</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;in_refraction_zone&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ycrit</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;turning point&#39;</span><span class="p">)</span>
            <span class="n">yarray</span><span class="p">,</span> <span class="n">zarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="p">[</span><span class="n">ycrit</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C0crit</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yarray</span><span class="p">,</span> <span class="n">zarray</span><span class="p">,</span> <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;C1d&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;emitter&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;receiver&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ycrit</span><span class="p">:</span>
            <span class="c1"># not in shadow zone</span>
            <span class="n">refraction</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; is_in_refraction_zone(): y-position of receiver smaller than ycrit!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># start horizontal ray at (y,z) = (ycrit,0)</span>
            <span class="c1"># experimentally this was found to give slightly different results than mirroring the array at the critical angle.</span>
            <span class="c1"># theoretically this is not quite unterstood</span>
            <span class="n">C0check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_0_from_angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">C0check</span> <span class="o">=</span> <span class="n">C0check</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gcheck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># print(&#39;C0check, gcheck&#39;,C0check,gcheck)</span>
            <span class="n">ycheck</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gcheck</span><span class="p">,</span> <span class="n">C0check</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">([</span><span class="n">ycrit</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C0check</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ycrit</span>
            <span class="c1"># print(&#39;ycheck, x2[1]&#39;,ycheck,x2[1])</span>
            <span class="k">if</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ycheck</span><span class="p">:</span>
                <span class="n">refraction</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">yarraymirr</span> <span class="o">=</span> <span class="o">-</span><span class="n">yarray</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ycrit</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yarraymirr</span><span class="p">,</span> <span class="n">zarray</span><span class="p">,</span> <span class="s1">&#39;mx-&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;mirrored path&#39;</span><span class="p">)</span>
                <span class="c1"># the reference point does not seem to lie exactly on the mirrored path but instead</span>
                <span class="c1"># ~1cm inside the path (i.e. towards the emmitter) which I do not understand.</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ycheck</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b+&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;reference point&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">refraction</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_tof_for_straight_line"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_tof_for_straight_line">[docs]</a>    <span class="k">def</span> <span class="nf">get_tof_for_straight_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the time of flight for a hypothatical ray travelling from x1 to x2 in a straight line.</span>
<span class="sd">        Such an array in general is not a solution consistant with Fermat&#39;s principle. It is however</span>
<span class="sd">        useful as a reference time or approximation for signals not explicable with geometric optics.</span>

<span class="sd">        output:</span>
<span class="sd">            time of flight for a ray travelling straight from x1 to x2</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_ice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">n_ice</span>
        <span class="n">delta_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">delta_n</span>
        <span class="n">z_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">z_0</span>

        <span class="k">if</span> <span class="n">dz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dx</span> <span class="o">/</span> <span class="n">dz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">n_ice</span> <span class="o">*</span> <span class="n">dz</span> <span class="o">-</span> <span class="n">delta_n</span> <span class="o">*</span> <span class="n">z_0</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">z_0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">z_0</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="n">dx</span></div>

<div class="viewcode-block" id="ray_tracing_2D.get_surface_pulse"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.get_surface_pulse">[docs]</a>    <span class="k">def</span> <span class="nf">get_surface_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">infirn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="s1">&#39;critical&#39;</span><span class="p">,</span> <span class="n">chdraw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the time for a ray to travel from x1 to the surface and arriving at the surface</span>
<span class="sd">        with (a) critical angle or (b) Brewster angle, propagating in a straight line along the surface</span>
<span class="sd">        in air (n=1) in the firn at z=0 (n=self.n(0)) and then reaching the receiver by returning into the</span>
<span class="sd">        firn just at the point to reach the receiver at x2, entering the firn at the surface at the same</span>
<span class="sd">        angle it reached the surface from x1..</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2: arrays</span>
<span class="sd">            Arrays with x and z positions of emitter x1 and receiver x2</span>
<span class="sd">        infirn: Boolean. </span>
<span class="sd">            Set to True if surface ray travels in the firn, set to False (default) if it travels</span>
<span class="sd">            in air.</span>
<span class="sd">        angle:  String </span>
<span class="sd">            specifying angle at which ray reaches/leaves the surface. Can be &#39;Brewster&#39; or &#39;critical&#39;</span>
<span class="sd">            If neither of these is chosen, a warning is printed and angle is set to &#39;critical&#39;</span>
<span class="sd">        chdraw: string or None</span>
<span class="sd">            If None, do not draw the path of the ray. If the ray should be drawn, a string consistent with</span>
<span class="sd">            the matplotlib.pyplot library has to be specified, e.g. &#39;r:&#39; to draw a dotted red line.</span>
<span class="sd">            It is assumed that an appropriate figure on which to draw the ray has been created and set as</span>
<span class="sd">            current figure by the user before calling this method.</span>
<span class="sd">        label:  Label for plot</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">chdraw</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">infirn</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">nlayer</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># index of refraction at surface, default is n=1 for air</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nlayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="s1">&#39;critical&#39;</span><span class="p">:</span>
            <span class="c1"># sin(th)=1,</span>
            <span class="n">nxsin</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="s1">&#39;Brewster&#39;</span><span class="p">:</span>
            <span class="n">nxsin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39; unknown input angle==</span><span class="si">{}</span><span class="s1">, using critical angle!!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
            <span class="n">nxsin</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">zsurf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">zsurf</span><span class="p">)</span>

        <span class="c1"># print(&#39;nxsin = &#39;,nxsin)</span>
        <span class="c1"># find emission angle for starting point x1 to hit the surface at the specified angle</span>

        <span class="c1"># look at time and distance it takes for the signal to travel from the emitter to the surface</span>
        <span class="c1"># and from the surface to the receiver</span>
        <span class="n">tice</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sice</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]:</span>
            <span class="n">sinthemit</span> <span class="o">=</span> <span class="n">nxsin</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">th_emit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">sinthemit</span><span class="p">)</span>
            <span class="n">C0result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_0_from_angle</span><span class="p">(</span><span class="n">th_emit</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">C0_emit</span> <span class="o">=</span> <span class="n">C0result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># print(C0_emit)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; emission angle for position </span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1"> is theta_emit= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">th_emit</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>

            <span class="c1"># x-coordinate where ray reaches surface; is always bigger than the x-position of the emitter</span>
            <span class="c1"># (i.e. ray travels &quot;to the right&quot;)</span>
            <span class="n">xsurf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C0_emit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C0_emit</span><span class="p">))</span>
            <span class="n">sice</span> <span class="o">+=</span> <span class="n">xsurf</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; air pulse starting at x=</span><span class="si">{}</span><span class="s1">, z=</span><span class="si">{}</span><span class="s1"> reaches surface at x=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xsurf</span><span class="p">))</span>
            <span class="n">ttosurf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_travel_time_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">xsurf</span><span class="p">,</span> <span class="n">zsurf</span><span class="p">],</span> <span class="n">C0_emit</span><span class="p">)</span>
            <span class="n">tice</span> <span class="o">+=</span> <span class="n">ttosurf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; travel time is </span><span class="si">{}</span><span class="s1"> ns.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ttosurf</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">ns</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zsurf</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">C0_emit</span><span class="p">,</span> <span class="n">C_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_C_1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C0_emit</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x1</span><span class="p">:</span>
                    <span class="n">ysurf</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ysurf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ysurf</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">chdraw</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">chdraw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; time, distance travelled to and from surface: </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tice</span><span class="p">,</span> <span class="n">sice</span><span class="p">))</span>

        <span class="n">sair</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">sice</span>
        <span class="n">tair</span> <span class="o">=</span> <span class="n">sair</span> <span class="o">*</span> <span class="n">nlayer</span> <span class="o">/</span> <span class="n">speed_of_light</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39; time, distance travelled at surface: </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tair</span><span class="p">,</span> <span class="n">sair</span><span class="p">))</span>
        <span class="n">ttot</span> <span class="o">=</span> <span class="n">tice</span> <span class="o">+</span> <span class="n">tair</span>
        <span class="k">if</span> <span class="n">sair</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ttot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ttot</span></div>

<div class="viewcode-block" id="ray_tracing_2D.angular_diff"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing_2D.angular_diff">[docs]</a>    <span class="k">def</span> <span class="nf">angular_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_refl</span><span class="p">,</span> <span class="n">z_refl</span><span class="p">,</span> <span class="n">pulser_pos</span><span class="p">,</span> <span class="n">receiver_pos</span><span class="p">,</span> <span class="n">ipulssol</span><span class="p">,</span> <span class="n">irxsol</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is a helper function to find a ray that is subject to specular reflection (no transmission) at the</span>
<span class="sd">        ice-water interface, e.g. for Moore&#39;s Bay. For a (virtual) emitter positioned at [x_refl,z_refl], it finds the</span>
<span class="sd">        emission angles such that the rays hit positions pulser_pos and receiver_pos. ipulssol = 0 or 1, respectively</span>
<span class="sd">        means that pulser_pos is hit directly or by means of reflection at the surface, respectively.</span>
<span class="sd">        irxsol is the equivalent parameter for receiver_pos.</span>

<span class="sd">        angular_diff can be used as the function to find a root of in the following fashion:</span>

<span class="sd">        result = optimize.root(raytr.angular_diff, x0=x_refl_start, args=(z_refl,pulser_pos,receiver_pos,ipulssol,irxsol))</span>

<span class="sd">        Then get the final value by x_refl = result.x[0] (z_refl is fixed)</span>

<span class="sd">        The idea is to treat the reflection point as a virtual emitter and then find the x-position at the predefined</span>
<span class="sd">        depth z_refl, for which the emisssion angles to pulser_pos and receiver_pos are the same (i.e. the output</span>
<span class="sd">        of angular_diff is zero). The x-position would be output &quot;result&quot; ofoptimize.root() above.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: float</span>
<span class="sd">            Is zero if the angles (w.r.t. the vertical) of rays emitted from [x_refl,z_refl] to</span>
<span class="sd">            positions pulser_pos and receiver_pos are the same or greater than zero, if this is not the case.</span>
<span class="sd">            For exact defintion, see &quot;result&quot; in code below</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># treat position of reflection as emitter and Rx/Tx as receivers</span>
        <span class="n">pos_rx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">receiver_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">receiver_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">x_refl</span> <span class="o">-</span> <span class="p">(</span><span class="n">pulser_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_refl</span><span class="p">),</span> <span class="n">pulser_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">]</span>
        <span class="n">beta0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">beta1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># solution for receiver</span>
        <span class="n">solution0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">([</span><span class="n">x_refl</span><span class="p">,</span> <span class="n">z_refl</span><span class="p">],</span> <span class="n">pos_rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution0</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">C0rx</span> <span class="o">=</span> <span class="n">solution0</span><span class="p">[</span><span class="n">irxsol</span><span class="p">][</span><span class="s1">&#39;C0&#39;</span><span class="p">]</span>
            <span class="n">beta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">([</span><span class="n">x_refl</span><span class="p">,</span> <span class="n">z_refl</span><span class="p">],</span> <span class="n">C0rx</span><span class="p">)</span>
        <span class="c1"># solution for pulser</span>
        <span class="n">solution1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">([</span><span class="n">x_refl</span><span class="p">,</span> <span class="n">z_refl</span><span class="p">],</span> <span class="n">pos_rx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution1</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">C0puls</span> <span class="o">=</span> <span class="n">solution1</span><span class="p">[</span><span class="n">ipulssol</span><span class="p">][</span><span class="s1">&#39;C0&#39;</span><span class="p">]</span>
            <span class="n">beta1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">([</span><span class="n">x_refl</span><span class="p">,</span> <span class="n">z_refl</span><span class="p">],</span> <span class="n">C0puls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">beta0</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">beta1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">beta0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">beta1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># set to infinity</span>

        <span class="k">return</span> <span class="n">result</span></div></div>


<div class="viewcode-block" id="ray_tracing"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing">[docs]</a><span class="k">class</span> <span class="nc">ray_tracing</span><span class="p">(</span><span class="n">ray_tracing_base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    utility class (wrapper around the 2D analytic ray tracing code) to get</span>
<span class="sd">    ray tracing solutions in 3D for two arbitrary points x1 and x2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">medium</span><span class="p">,</span> <span class="n">attenuation_model</span><span class="o">=</span><span class="s2">&quot;SP1&quot;</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
                 <span class="n">n_frequencies_integration</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_reflections</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">detector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        class initilization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        medium: medium class</span>
<span class="sd">            class describing the index-of-refraction profile</span>
<span class="sd">        attenuation_model: string</span>
<span class="sd">            signal attenuation model</span>
<span class="sd">        log_name:  string</span>
<span class="sd">            name under which things should be logged</span>
<span class="sd">        log_level: logging object</span>
<span class="sd">            specify the log level of the ray tracing class</span>
<span class="sd">            * logging.ERROR</span>
<span class="sd">            * logging.WARNING</span>
<span class="sd">            * logging.INFO</span>
<span class="sd">            * logging.DEBUG</span>
<span class="sd">            </span>
<span class="sd">            default is WARNING</span>
<span class="sd">        n_frequencies_integration: int</span>
<span class="sd">            the number of frequencies for which the frequency dependent attenuation</span>
<span class="sd">            length is being calculated. The attenuation length for all other frequencies</span>
<span class="sd">            is obtained via linear interpolation.</span>
<span class="sd">        n_reflections: int (default 0)</span>
<span class="sd">            in case of a medium with a reflective layer at the bottom, how many reflections should be considered</span>
<span class="sd">        config: dict</span>
<span class="sd">            a dictionary with the optional config settings. If None, the config is intialized with default values,</span>
<span class="sd">            which is needed to avoid any &quot;key not available&quot; errors. The default settings are</span>
<span class="sd">                self._config = {&#39;propagation&#39;: {}}</span>
<span class="sd">                self._config[&#39;propagation&#39;][&#39;attenuate_ice&#39;] = True</span>
<span class="sd">                self._config[&#39;propagation&#39;][&#39;focusing_limit&#39;] = 2</span>
<span class="sd">                self._config[&#39;propagation&#39;][&#39;focusing&#39;] = False</span>
<span class="sd">        detector: detector object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ray_tracing_analytic&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">NuRadioMC.utilities.medium_base</span> <span class="kn">import</span> <span class="n">IceModelSimple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">medium</span><span class="p">,</span><span class="n">IceModelSimple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The analytic raytracer can only handle ice model of the type &#39;IceModelSimple&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The analytic raytracer can only handle ice model of the type &#39;IceModelSimple&#39;&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">medium</span><span class="o">=</span><span class="n">medium</span><span class="p">,</span> 
                         <span class="n">attenuation_model</span><span class="o">=</span><span class="n">attenuation_model</span><span class="p">,</span>
                         <span class="n">log_level</span><span class="o">=</span><span class="n">log_level</span><span class="p">,</span>
                         <span class="n">n_frequencies_integration</span><span class="o">=</span><span class="n">n_frequencies_integration</span><span class="p">,</span> 
                         <span class="n">n_reflections</span><span class="o">=</span><span class="n">n_reflections</span><span class="p">,</span>
                         <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> 
                         <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span> <span class="o">=</span> <span class="n">ray_tracing_2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attenuation_model</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="n">log_level</span><span class="p">,</span>
                                    <span class="n">n_frequencies_integration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_frequencies_integration</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_R</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="kc">None</span>
        
<div class="viewcode-block" id="ray_tracing.reset_solutions"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.reset_solutions">[docs]</a>    <span class="k">def</span> <span class="nf">reset_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the raytracing solutions back to None. This is useful to do when changing the start and end</span>
<span class="sd">        points in order to not accidentally use results from previous raytracings.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset_solutions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_R</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ray_tracing.set_start_and_end_point"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.set_start_and_end_point">[docs]</a>    <span class="k">def</span> <span class="nf">set_start_and_end_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the start and end points of the raytracing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1: 3dim np.array</span>
<span class="sd">            start point of the ray</span>
<span class="sd">        x2: 3dim np.array</span>
<span class="sd">            stop point of the ray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_start_and_end_point</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;swap = True&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="n">dX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dX</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dX</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">X1r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span>
        <span class="n">X2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;X1 = </span><span class="si">{}</span><span class="s2">, X2 = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;dphi = </span><span class="si">{:.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dPhi</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;X2 - X1 = </span><span class="si">{}</span><span class="s2">, X1r = </span><span class="si">{}</span><span class="s2">, X2r = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">,</span> <span class="n">X1r</span><span class="p">,</span> <span class="n">X2r</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X1r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X1r</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X2r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X2r</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;2D points </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="ray_tracing.set_solution"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.set_solution">[docs]</a>    <span class="k">def</span> <span class="nf">set_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raytracing_results</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read an already calculated raytracing solution from the input array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raytracing_results: dict</span>
<span class="sd">            The dictionary containing the raytracing solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">C0s</span> <span class="o">=</span> <span class="n">raytracing_results</span><span class="p">[</span><span class="s1">&#39;ray_tracing_C0&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C0s</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">C0s</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">if</span> <span class="s1">&#39;ray_tracing_reflection&#39;</span> <span class="ow">in</span> <span class="n">raytracing_results</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># for backward compatibility: Check if reflection layer information exists in data file</span>
                    <span class="n">reflection</span> <span class="o">=</span> <span class="n">raytracing_results</span><span class="p">[</span><span class="s1">&#39;ray_tracing_reflection&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">reflection_case</span> <span class="o">=</span> <span class="n">raytracing_results</span><span class="p">[</span><span class="s1">&#39;ray_tracing_reflection_case&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reflection</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">reflection_case</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">raytracing_results</span><span class="p">[</span><span class="s1">&#39;ray_tracing_solution_type&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                <span class="s1">&#39;C0&#39;</span><span class="p">:</span> <span class="n">C0s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                <span class="s1">&#39;C1&#39;</span><span class="p">:</span> <span class="n">raytracing_results</span><span class="p">[</span><span class="s1">&#39;ray_tracing_C1&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                <span class="s1">&#39;reflection&#39;</span><span class="p">:</span> <span class="n">reflection</span><span class="p">,</span>
                                <span class="s1">&#39;reflection_case&#39;</span><span class="p">:</span> <span class="n">reflection_case</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">results</span></div>

<div class="viewcode-block" id="ray_tracing.find_solutions"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.find_solutions">[docs]</a>    <span class="k">def</span> <span class="nf">find_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find all solutions between x1 and x2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_reflections</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reflection_case</span><span class="o">=</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># check if not too many solutions were found (the same solution can potentially found twice because of numerical imprecision)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_raytracing_solutions</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span><span class="si">}</span><span class="s2"> were found but only </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_raytracing_solutions</span><span class="p">()</span><span class="si">}</span><span class="s2"> are allowed! Returning zero solutions&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="ray_tracing.get_solution_type"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_solution_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_solution_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the type of the solution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        solution_type: int</span>
<span class="sd">            integer corresponding to the types in the dictionary solution_types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">determine_solution_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;C0&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_path"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_path_reflections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
                                                 <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                 <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
        <span class="n">path_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="n">zz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dP</span> <span class="o">=</span> <span class="n">path_2d</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">MM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dP</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">MM</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="ray_tracing.get_launch_vector"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_launch_vector">[docs]</a>    <span class="k">def</span> <span class="nf">get_launch_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the launch vector (in 3D) of solution iS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        launch_vector: 3dim np.array</span>
<span class="sd">            the launch vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span> <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                            <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
        <span class="n">launch_vector_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_receive_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                 <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                 <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
            <span class="n">launch_vector_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">launch_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">launch_vector_2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">launch_vector</span></div>

<div class="viewcode-block" id="ray_tracing.get_receive_vector"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_receive_vector">[docs]</a>    <span class="k">def</span> <span class="nf">get_receive_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the receive vector (in 3D) of solution iS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        receive_vector: 3dim np.array</span>
<span class="sd">            the receive vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_receive_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                             <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                             <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
        <span class="n">receive_vector_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_launch_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
            <span class="n">receive_vector_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="n">receive_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">receive_vector_2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">receive_vector</span></div>

<div class="viewcode-block" id="ray_tracing.get_reflection_angle"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_reflection_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_reflection_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the angle of reflection at the surface (in case of a reflected ray)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reflection_angle: float or None</span>
<span class="sd">            the reflection angle (for reflected rays) or None for direct and refracted rays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_reflection_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                               <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span> <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_path_length"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_path_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the path length of solution iS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        analytic: bool</span>
<span class="sd">            If True the analytic solution is used. If False, a numerical integration is used. (default: True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distance: float</span>
<span class="sd">            distance from x1 to x2 along the ray path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">analytic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">analytic_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_path_length_analytic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                                      <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                                      <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">analytic_length</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">analytic_length</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;analytic calculation of travel time failed, switching to numerical integration&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_path_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                  <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                  <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_path_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                              <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                              <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_travel_time"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_travel_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_travel_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the travel time of solution iS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        analytic: bool</span>
<span class="sd">            If True the analytic solution is used. If False, a numerical integration is used. (default: True)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        time: float</span>
<span class="sd">            travel time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="n">analytic</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">analytic_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_travel_time_analytic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                                <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                                <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">analytic_time</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">analytic_time</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;analytic calculation of travel time failed, switching to numerical integration&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_travel_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                                  <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                  <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_travel_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
                                              <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                              <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_attenuation"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_attenuation">[docs]</a>    <span class="k">def</span> <span class="nf">get_attenuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates the signal attenuation due to attenuation in the medium (ice)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        frequency: array of floats</span>
<span class="sd">            the frequencies for which the attenuation is calculated</span>

<span class="sd">        max_detector_freq: float or None</span>
<span class="sd">            the maximum frequency of the final detector sampling</span>
<span class="sd">            (the simulation is internally run with a higher sampling rate, but the relevant part of the attenuation length</span>
<span class="sd">            calculation is the frequency interval visible by the detector, hence a finer calculation is more important)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attenuation: array of floats</span>
<span class="sd">            the fraction of the signal that reaches the observer</span>
<span class="sd">            (only ice attenuation, the 1/R signal falloff not considered here)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">iS</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution number </span><span class="si">{:d}</span><span class="s2"> requested but only </span><span class="si">{:d}</span><span class="s2"> solutions exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_attenuation_along_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">max_detector_freq</span><span class="p">,</span>
                                                     <span class="n">reflection</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                                     <span class="n">reflection_case</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_focusing"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_focusing">[docs]</a>    <span class="k">def</span> <span class="nf">get_focusing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">dz</span><span class="o">=-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">2.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate the focusing effect in the medium</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iS: int</span>
<span class="sd">            choose for which solution to compute the launch vector, counting</span>
<span class="sd">            starts at zero</span>

<span class="sd">        dz: float</span>
<span class="sd">            the infinitesimal change of the depth of the receiver, 1cm by default</span>
<span class="sd">        limit: float</span>
<span class="sd">            The maximum signal focusing.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        focusing: a float</span>
<span class="sd">            gain of the signal at the receiver due to the focusing effect:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">recVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_receive_vector</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="n">recVec</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">recVec</span>
        <span class="n">recAng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">recVec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">recVec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">recVec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">recVec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">lauVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_launch_vector</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="n">lauAng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">lauVec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lauVec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lauVec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lauVec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_length</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="c1"># we need to be careful here. If X1 (the emitter) is above the X2 (the receiver) the positions are swapped</span>
        <span class="c1"># do to technical reasons. Here, we want to change the receiver position slightly, so we need to check</span>
        <span class="c1"># is X1 and X2 was swapped and use the receiver value!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span><span class="p">:</span>
            <span class="n">vetPos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">)</span>
            <span class="n">recPos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">)</span>
            <span class="n">recPos1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dz</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vetPos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">)</span>
            <span class="n">recPos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">)</span>
            <span class="n">recPos1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dz</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_r1&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span> <span class="o">=</span> <span class="n">ray_tracing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attenuation_model</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_n_frequencies_integration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_reflections</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span><span class="o">.</span><span class="n">set_start_and_end_point</span><span class="p">(</span><span class="n">vetPos</span><span class="p">,</span> <span class="n">recPos1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span><span class="o">.</span><span class="n">find_solutions</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">iS</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span><span class="o">.</span><span class="n">get_number_of_solutions</span><span class="p">():</span>
            <span class="n">lauVec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span><span class="o">.</span><span class="n">get_launch_vector</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
            <span class="n">lauAng1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">lauVec1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lauVec1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lauVec1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lauVec1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">focusing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">recAng</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">lauAng1</span> <span class="o">-</span> <span class="n">lauAng</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">recPos1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">recPos</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_solution_type</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r1</span><span class="o">.</span><span class="n">get_solution_type</span><span class="p">(</span><span class="n">iS</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;solution types are not the same&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">focusing</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;too few ray tracing solutions, setting focusing factor to 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;amplification due to focusing of solution </span><span class="si">{</span><span class="n">iS</span><span class="si">:</span><span class="s1">d</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">focusing</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">focusing</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;amplification due to focusing is </span><span class="si">{</span><span class="n">focusing</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x -&gt; limiting amplification factor to </span><span class="si">{</span><span class="n">limit</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>
            <span class="n">focusing</span> <span class="o">=</span> <span class="n">limit</span>

        <span class="c1"># now also correct for differences in refractive index between emitter and receiver position</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_swap</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">)</span>  <span class="c1"># emitter</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">)</span>  <span class="c1"># receiver</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X1</span><span class="p">)</span>  <span class="c1"># emitter</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">)</span>  <span class="c1"># receiver</span>
        <span class="k">return</span> <span class="n">focusing</span> <span class="o">*</span> <span class="p">(</span><span class="n">n1</span> <span class="o">/</span> <span class="n">n2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>

<div class="viewcode-block" id="ray_tracing.get_ray_path"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_ray_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_ray_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iS</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r2d</span><span class="o">.</span><span class="n">get_path_reflections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span> <span class="mi">10000</span><span class="p">,</span>
                                   <span class="n">reflection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
                                   <span class="n">reflection_case</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ray_tracing.get_output_parameters"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_output_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_output_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ray_tracing_C0&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ray_tracing_C1&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;focusing_factor&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ray_tracing_reflection&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ray_tracing_reflection_case&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ray_tracing_solution_type&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="ray_tracing.get_raytracing_output"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.get_raytracing_output">[docs]</a>    <span class="k">def</span> <span class="nf">get_raytracing_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_solution</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing&#39;</span><span class="p">]:</span>    
            <span class="n">focusing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_focusing</span><span class="p">(</span><span class="n">i_solution</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing_limit&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">focusing</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;ray_tracing_C0&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()[</span><span class="n">i_solution</span><span class="p">][</span><span class="s1">&#39;C0&#39;</span><span class="p">],</span>
            <span class="s1">&#39;ray_tracing_C1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()[</span><span class="n">i_solution</span><span class="p">][</span><span class="s1">&#39;C1&#39;</span><span class="p">],</span>
            <span class="s1">&#39;ray_tracing_reflection&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()[</span><span class="n">i_solution</span><span class="p">][</span><span class="s1">&#39;reflection&#39;</span><span class="p">],</span>
            <span class="s1">&#39;ray_tracing_reflection_case&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()[</span><span class="n">i_solution</span><span class="p">][</span><span class="s1">&#39;reflection_case&#39;</span><span class="p">],</span>
            <span class="s1">&#39;ray_tracing_solution_type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_solution_type</span><span class="p">(</span><span class="n">i_solution</span><span class="p">),</span>
            <span class="s1">&#39;focusing_factor&#39;</span><span class="p">:</span> <span class="n">focusing</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="ray_tracing.apply_propagation_effects"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.apply_propagation_effects">[docs]</a>    <span class="k">def</span> <span class="nf">apply_propagation_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">efield</span><span class="p">,</span> <span class="n">i_solution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply propagation effects to the electric field</span>
<span class="sd">        Note that the 1/r weakening of the electric field is already accounted for in the signal generation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        efield: ElectricField object</span>
<span class="sd">            The electric field that the effects should be applied to</span>
<span class="sd">        i_solution: int</span>
<span class="sd">            Index of the raytracing solution the propagation effects should be based on</span>

<span class="sd">        Returns</span>
<span class="sd">        -------------</span>
<span class="sd">        efield: ElectricField object</span>
<span class="sd">            The modified ElectricField object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">efield</span><span class="o">.</span><span class="n">get_frequency_spectrum</span><span class="p">()</span>
        <span class="n">apply_attenuation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;attenuate_ice&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">apply_attenuation</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_detector_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">efield</span><span class="o">.</span><span class="n">get_frequencies</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_detector_frequency</span>
            <span class="n">attenuation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attenuation</span><span class="p">(</span><span class="n">i_solution</span><span class="p">,</span> <span class="n">efield</span><span class="o">.</span><span class="n">get_frequencies</span><span class="p">(),</span> <span class="n">max_freq</span><span class="p">)</span>
            <span class="n">spec</span> <span class="o">*=</span> <span class="n">attenuation</span>

        <span class="n">zenith_reflections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_reflection_angle</span><span class="p">(</span><span class="n">i_solution</span><span class="p">))</span>  <span class="c1"># lets handle the general case of multiple reflections off the surface (possible if also a reflective bottom layer exists)</span>
        <span class="k">for</span> <span class="n">zenith_reflection</span> <span class="ow">in</span> <span class="n">zenith_reflections</span><span class="p">:</span>  <span class="c1"># loop through all possible reflections</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zenith_reflection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># skip all ray segments where not reflection at surface happens</span>
                <span class="k">continue</span>
            <span class="n">r_theta</span> <span class="o">=</span> <span class="n">NuRadioReco</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">geometryUtilities</span><span class="o">.</span><span class="n">get_fresnel_r_p</span><span class="p">(</span>
                <span class="n">zenith_reflection</span><span class="p">,</span> <span class="n">n_2</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">n_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="p">]))</span>
            <span class="n">r_phi</span> <span class="o">=</span> <span class="n">NuRadioReco</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">geometryUtilities</span><span class="o">.</span><span class="n">get_fresnel_r_s</span><span class="p">(</span>
                <span class="n">zenith_reflection</span><span class="p">,</span> <span class="n">n_2</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">n_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">get_index_of_refraction</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="p">]))</span>
            <span class="n">efield</span><span class="p">[</span><span class="n">efp</span><span class="o">.</span><span class="n">reflection_coefficient_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_theta</span>
            <span class="n">efield</span><span class="p">[</span><span class="n">efp</span><span class="o">.</span><span class="n">reflection_coefficient_phi</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_phi</span>

            <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">r_theta</span>
            <span class="n">spec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">r_phi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;ray hits the surface at an angle </span><span class="si">{:.2f}</span><span class="s2">deg -&gt; reflection coefficient is r_theta = </span><span class="si">{:.2f}</span><span class="s2">, r_phi = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">zenith_reflection</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
                    <span class="n">r_theta</span><span class="p">,</span> <span class="n">r_phi</span><span class="p">))</span>
        <span class="n">i_reflections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()[</span><span class="n">i_solution</span><span class="p">][</span><span class="s1">&#39;reflection&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i_reflections</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># take into account possible bottom reflections</span>
            <span class="c1"># each reflection lowers the amplitude by the reflection coefficient and introduces a phase shift</span>
            <span class="n">reflection_coefficient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">reflection_coefficient</span> <span class="o">**</span> <span class="n">i_reflections</span>
            <span class="n">phase_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_reflections</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_medium</span><span class="o">.</span><span class="n">reflection_phase_shift</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1"># we assume that both efield components are equally affected</span>
            <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">reflection_coefficient</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shift</span><span class="p">)</span>
            <span class="n">spec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">reflection_coefficient</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shift</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;ray is reflecting </span><span class="si">{</span><span class="n">i_reflections</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> times at the bottom -&gt; reducing the signal by a factor of </span><span class="si">{</span><span class="n">reflection_coefficient</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># apply the focusing effect</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing&#39;</span><span class="p">]:</span>
            <span class="n">focusing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_focusing</span><span class="p">(</span><span class="n">i_solution</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing_limit&#39;</span><span class="p">]))</span>
            <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="n">focusing</span>

        <span class="n">efield</span><span class="o">.</span><span class="n">set_frequency_spectrum</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">efield</span><span class="o">.</span><span class="n">get_sampling_rate</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">efield</span></div>

<div class="viewcode-block" id="ray_tracing.set_config"><a class="viewcode-back" href="../../../NuRadioMC/apidoc/NuRadioMC.SignalProp.analyticraytracing.html#NuRadioMC.SignalProp.analyticraytracing.ray_tracing.set_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the configuration file used by the raytracer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config: dict or None</span>
<span class="sd">            The new configuration settings</span>
<span class="sd">            If None, the default config settings will be applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;propagation&#39;</span><span class="p">:</span> <span class="p">{}}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;attenuate_ice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing_limit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;propagation&#39;</span><span class="p">][</span><span class="s1">&#39;focusing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">config</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The NuRadio Group.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>